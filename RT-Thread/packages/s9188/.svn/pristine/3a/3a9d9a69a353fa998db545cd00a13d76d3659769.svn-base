



#define THREAD_PRORTIY		6			//优先级
#define	THREAD_STACK_SIZE	512		//栈大小
#define THREAD_TIMESLICE	5			//线程时间片
#include "os.h"

static struct rt_messagequeue wifi_msg_queue = NULL;
static rt_uint8_t	msg_pool[1024];


int wf_rt_get_bssid(void *pnic_info,u8 *bssid)
{
	nic_info_st *nic_info = pnic_info;
	wf_wlan_mgmt_info_t *pwlan_info = nic_info->wlan_mgmt_info;
	wf_wlan_network_t *pcur_network = &pwlan_info->cur_network;
	if(pcur_network->bssid == NULL)
	{
		return -1;
	}
	wf_memcpy(bssid, pcur_network->bssid, WF_ETH_ALEN);
	return 0;
}


u32 wpaalg_to_alg(u32 alg)
{
	enum wpa_alg temp = (enum wpa_alg)alg;

	if (temp == WPA_ALG_NONE)
		return IW_AUTH_CIPHER_NONE;
	else if (temp == WPA_ALG_WEP)
		return WLAN_CIPHER_SUITE_WEP40;
	else if (temp == WPA_ALG_TKIP)
		return WLAN_CIPHER_SUITE_TKIP;
	else if (temp == WPA_ALG_CCMP)
		return WLAN_CIPHER_SUITE_CCMP;

	return 0;
}


int wf_rt_add_key(void *pnic_info,int key_idx, int pairwise, const u8 * addr, u32 alg,
				   const u8 * seq, size_t seq_len,
				   const u8 * key, size_t key_len)
{
	nic_info_st *nic_info = pnic_info;
	struct key_params key_para;

	key_para.seq = (u8 *) seq;
	key_para.seq_len = seq_len;
	key_para.key = (u8 *) key;
	key_para.key_len = key_len;
	key_para.cipher = wpaalg_to_alg(alg);

	wf_rt_add_key(pnic_info,key_idx,addr,&key_para);
	return 0;
}


int wf_rt_get_ssid(void *pnic_info,u8 *ssid)
{
	nic_info_st *nic_info = pnic_info;
	wf_wlan_mgmt_info_t *pwlan_info = nic_info->wlan_mgmt_info;
	wf_wlan_network_t *pcur_network = &pwlan_info->cur_network;
	if(pcur_network->ssid.data == NULL)
	{
		return -1;
	}
	wf_memcpy(ssid, pcur_network->ssid.data, WF_ETH_ALEN);
	return 0;
}
const struct wpa_driver_ops wpa_driver_bsd_ops = {
	.name = "bsd",
	.desc = "BSD 802.11 support",
#ifdef HOSTAPD
	.hapd_init = bsd_init,
	.hapd_deinit = bsd_deinit,
	.set_privacy = bsd_set_privacy,
	.get_seqnum = bsd_get_seqnum,
	.flush = bsd_flush,
	.read_sta_data = bsd_read_sta_driver_data,
	.sta_disassoc = bsd_sta_disassoc,
	.sta_deauth = bsd_sta_deauth,
	.sta_set_flags = bsd_set_sta_authorized,
	.commit = bsd_commit,
#else
	.find_bssid = wf_rt_get_bssid,
	.get_ssid = wf_rt_get_ssid,
#endif
	.set_key = wf_rt_add_key,
};

int wf_wifi_init(nic_info_st *pnic_info)
{
	rt_err_t result;
	rt_thread_t tid = NULL;
	
	result = rt_mq_init(&wifi_msg_queue,"wifi_work_queue",&msg_pool,
						sizeof(wf_wifi_msg_t),sizeof(msg_pool),
						RT_IPC_FLAG_FIFO);
	if(result != RT_EOK)
	{
		return -1;
	}

	tid = rt_thread_create("wifi thread",wf_wifithread,pnic_info,
						THREAD_STACK_SIZE,THREAD_PRORTIY,
						THREAD_TIMESLICE);
	if(tid != RT_EOK)
	{
		return -1;
	}
	rt_thread_startup(tid);
	return 0;
}


struct wpa_config *wpa_config_alloc_empty(const char *ctrl_interface,
										  const char *driver_param)
{
	struct wpa_config *config;

	config = &wpaconfig;
	if (config == NULL)
		return NULL;
	config->eapol_version = DEFAULT_EAPOL_VERSION;
	config->ap_scan = 1;
	config->user_mpm = DEFAULT_USER_MPM;
	config->max_peer_links = DEFAULT_MAX_PEER_LINKS;
	config->mesh_max_inactivity = DEFAULT_MESH_MAX_INACTIVITY;
	config->dot11RSNASAERetransPeriod = DEFAULT_DOT11_RSNA_SAE_RETRANS_PERIOD;
	config->fast_reauth = DEFAULT_FAST_REAUTH;
	config->bss_max_count = DEFAULT_BSS_MAX_COUNT;
	config->bss_expiration_age = DEFAULT_BSS_EXPIRATION_AGE;
	config->bss_expiration_scan_count = DEFAULT_BSS_EXPIRATION_SCAN_COUNT;
	config->max_num_sta = DEFAULT_MAX_NUM_STA;
	config->access_network_type = DEFAULT_ACCESS_NETWORK_TYPE;
	config->scan_cur_freq = DEFAULT_SCAN_CUR_FREQ;
	config->p2p_search_delay = DEFAULT_P2P_SEARCH_DELAY;
	config->rand_addr_lifetime = DEFAULT_RAND_ADDR_LIFETIME;
	config->key_mgmt_offload = DEFAULT_KEY_MGMT_OFFLOAD;
	config->cert_in_cb = DEFAULT_CERT_IN_CB;
#ifdef NOT_FIXED
	if (ctrl_interface)
		config->ctrl_interface = os_strdup(ctrl_interface);
	if (driver_param)
		config->driver_param = os_strdup(driver_param);
#endif
	return config;
}


struct wpa_config *wpa_config_read(const char *name, struct wpa_config *cfgp)
{
	struct wpa_config *config;

	if (name == NULL)
		return NULL;
	if (cfgp)
		config = cfgp;
	else
		config = wpa_config_alloc_empty(NULL, NULL);
	if (config == NULL)
		return NULL;

	return config;
}


void PRF( u8 * key,
		  int key_len,
		  u8 * prefix,
		  int prefix_len,
		  u8 * data,  int data_len,  u8 * output,  int len)
{
	int i;
	u8 input[1024];
	int currentindex = 0;
	int total_len;

	os_memcpy(input, prefix, prefix_len);
	input[prefix_len] = 0;
	os_memcpy(&input[prefix_len + 1], data, data_len);
	total_len = prefix_len + 1 + data_len;
	input[total_len] = 0;
	total_len++;
	for (i = 0; i < (len + 19) / 20; i++) {
		hmac_sha1(input, total_len, key, key_len, &output[currentindex]);
		currentindex += 20;
		input[total_len - 1]++;
	}
}


void WpaCountGTK(u8 * GMK,
				  u8 * GNonce,
				  u8 * AA,  u8 * output,  UINT len)
{
	u8 concatenation[38];
	u32 CurrPos = 0;
	u8 Prefix[] = { 'G', 'r', 'o', 'u', 'p', ' ', 'k', 'e', 'y', ' ',
		'e', 'x', 'p', 'a', 'n', 's', 'i', 'o', 'n'
	};
	os_memcpy(concatenation, AA, 6);
	CurrPos += 6;
	os_memcpy(&concatenation[CurrPos], GNonce, 32);
	CurrPos += 32;
	PRF(GMK, 32, Prefix, 19, concatenation, 38, output, len);
}


void ap_sta_init(struct hostapd_data *hapd)
{
	int i = 0;

	hapd->num_sta = 0;

	hapd->acct_session_id_lo = hapd->acct_session_id_hi = 1;

	hapd->sta_list = NULL;

	for (i = 0; i < STA_HASH_SIZE; i++) {

		hapd->sta_hash[i] = NULL;
	}

}



void Wpa_Supplicant_Config(const u8 * hwaddr, int len, char *essid,
						   char *password, int ap_mode)
{
	struct wpa_supplicant *wpa_s = &wpa_s_obj;
	static int wpa_init = 0;
	struct wpa_ssid *entry;

	u8 psk[32];
	UCHAR GNonce[32];
	UCHAR GTK[40];
	UCHAR GMK[32];

	if (!wpa_init) {
		wpa_init = 1;
		memset(wpa_s, 0, sizeof(struct wpa_supplicant));
		wpa_s->wpa = wpa_sm_init(wpa_s);
		if (wpa_s->wpa == NULL) {
			return;
		}
		wpa_sm_set_param(wpa_s->wpa, WPA_PARAM_PROTO, WPA_RSN_PROTO);
		wpa_s->driver = &wpa_driver_bsd_ops;
		
		wpa_s->confname = "sci-wifi";
		wpa_s->conf = wpa_config_read(wpa_s->confname, NULL);
		if (wpa_s->conf == NULL) {
			return;
		}
		wpa_s->conf->ap_scan = 1;
		wpa_supplicant_ctrl_iface_add_network(wpa_s);
	}

	wpa_s->ap_mode_start = ap_mode;
	os_memcpy(wpa_s->wpa->own_addr, hwaddr, len);
	if (!wpa_s->ap_mode_start) {

		if (!password || !essid || !strlen(essid) || !strlen(password)) {

			return;
		}

		entry = wpa_s->conf->ssid;
		entry->key_mgmt = WPA_PSK_KEY_MGMT;
		entry->ssid = (u8 *) essid;
		entry->ssid_len = strlen(essid);
		entry->passphrase = password;
		entry->disabled = 0;
		os_memset(entry->psk, 0, 32);
		pbkdf2_sha1((char *)entry->passphrase, entry->ssid, entry->ssid_len,
					4096, entry->psk, PMK_LEN);
		entry->psk_set = 1;
		wpa_s->confanother = NULL;

	} else {
		pbkdf2_sha1(password, (u8 *)essid, strlen(essid), 4096, psk, PMK_LEN);
		os_memcpy(wpa_s->hapd.pmk, psk, PMK_LEN);
		wpa_s->hapd.pmk_len = PMK_LEN;
		os_memcpy(wpa_s->hapd.own_addr, hwaddr, len);
		os_memset(GTK, 0, 40);
		os_get_random(GMK, WPA_LEN_NONCE);
		os_get_random(GNonce, WPA_LEN_NONCE);

		WpaCountGTK(GMK, GNonce, wpa_s->hapd.own_addr, GTK, 32);

		os_memcpy(wpa_s->hapd.GTK, GTK, 32);

		wpa_s->hapd.gtk_installed = 0;

		ap_sta_init(&wpa_s->hapd);

	}
}

static int wifi_try_connect(nic_info_st *pnic_info, char *ssid, char *password, int channel)
{
	wf_bool state;
	wf_mlme_get_connect(pnic_info, &state);
	if(state == wf_true)
	{
		wf_deauth_xmit_frame(pnic_info, wf_wlan_get_cur_bssid(pnic_info),
			WF_80211_REASON_DEAUTH_LEAVING);
	}
    wf_mlme_conn_start(pnic_info, NULL, &ssid,
    WF_MLME_FRAMEWORK_WEXT, wf_true);
	wf_mlme_get_connect(pnic_info, &state);
	if(state == wf_true)
		return 0;
	return -1;

	
}

static int wf_sta_start(nic_info_st *pnic_info, char *ssid, char *pwd, int channel)
{
	wf_u32 ret;
	hw_info_st *phw_info = pnic_info->hw_info;
	Wpa_Supplicant_Config(phw_info->macAddr, ETH_ALEN, ssid,
						  pwd, 0);
	ret = wifi_try_connect(pnic_info,ssid,pwd,channel);
	if(ret != 0)
		return -1;
	return 0;
}

static void wf_wifithread(nic_info_st *pnic_info)
{
	rt_uint8_t *buf;
	wf_wifi_msg_t *pmsg;
	wf_sta_mode_para_t *sta_info;
	while(1)
	{
		if(rt_mq_recv(&wifi_msg_queue, 
					&buf, sizeof(wf_wifi_msg_t),
					RT_WAITING_FOREVER) == RT_EOK)
		{
			pmsg = (wf_wifi_msg_t *)buf;
			sta_info = (wf_sta_mode_para_t *)pmsg->para;
			switch (pmsg->type)
			{
				case WIFI_BSP_STARTSTA:
					wf_sta_start(pnic_info,&sta_info->ssid,
								&sta_info->pwd,sta_info->channel);
				break;
				case WIFI_BSP_STOPSTA:
				break;
				case WIFI_BSP_SCAN:
				break;
				default:
				break;
			}

		}
	}
}
