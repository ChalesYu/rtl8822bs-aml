#include "common.h"
#include "wf_debug.h"



static wf_bool wf_is_8021x_auth (wf_80211_mgmt_ie_t *pies, wf_u16 ies_len)
{
    wf_80211_mgmt_ie_t *pie;

    if (!wf_80211_mgmt_ies_search(pies, ies_len,
                                  WF_80211_MGMT_EID_RSN, &pie))
    {
        LOG_D("RSN");
        return wf_true;
    }

    if (!wf_80211_mgmt_ies_search(pies, ies_len,
                                  WF_80211_MGMT_EID_VENDOR_SPECIFIC, &pie))
    {
        wf_u32 pmulticast_cipher, punicast_cipher;
        if (!wf_80211_mgmt_wpa_parse(pie,
                                     WF_OFFSETOF(wf_80211_mgmt_ie_t, data) + pie->len,
                                     &pmulticast_cipher,
                                     &punicast_cipher))
        {
            LOG_D("WPA");
            return wf_true;
        }
    }

    LOG_D("NO 8021X");
    return wf_false;
}


static rt_err_t wf_wlan_init(struct rt_wlan_device *wlan)
{
  nic_info_st *pnic_info = wlan->user_data;
  
  LOG_D("F:%s L:%d", __FUNCTION__, __LINE__);
  
  if (nic_init(pnic_info)<0)
    return -1;
  
//  tx_work_init(ndev);
//  
//  hw_info = (hw_info_st *)pnic_info->hw_info;
//  if (hw_info)
//  {
//    //memcpy(hw_info->macAddr,macAddr1,6);
//    if (!is_valid_ether_addr(hw_info->macAddr))
//    {
//      return -1;
//    }
//    
//    //      memcpy(ndev->dev_addr, hw_info->macAddr+flag, WF_ETH_ALEN);
//    //      flag++;
//    NDEV_INFO("efuse_macaddr:"WF_MAC_FMT,WF_MAC_ARG(hw_info->macAddr));
//#ifdef CONFIG_CONCURRENT_MODE
//    if(ndev_priv->nic->nic_num == 0)
//    {
//#endif
//      memcpy(ndev->dev_addr, hw_info->macAddr, WF_ETH_ALEN);
//      //wf_mcu_hw_var_set_macaddr(ndev_priv->nic,ndev->dev_addr);
//#ifdef CONFIG_CONCURRENT_MODE
//    }
//    else if(ndev_priv->nic->nic_num == 1)
//    {
//      hw_info->macAddr[0] = hw_info->macAddr[0] + 0x2;
//      memcpy(ndev->dev_addr, hw_info->macAddr, WF_ETH_ALEN);
//      //wf_mcu_hw_var_set_macaddr(ndev_priv->nic,ndev->dev_addr);
//    }
//#endif
//    wf_mcu_hw_var_set_macaddr(ndev_priv->nic,ndev->dev_addr);
//    //        SET_NETDEV_DEV(ndev, ndev_priv->nic->dev);
//  } 
  
  return RT_EOK;
}

static rt_err_t wf_wlan_mode(struct rt_wlan_device *wlan, rt_wlan_mode_t mode)
{
  LOG_D("F:%s L:%d mode:%d", __FUNCTION__, __LINE__, mode);
  nic_info_st *pnic_info = wlan->user_data;
  local_info_st * plocal = (local_info_st *)pnic_info->local_info;
  wf_bool bConnect = wf_false;
  wf_wlan_mgmt_info_t *wlan_mgmt_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *cur_network = &wlan_mgmt_info->cur_network;
  sys_work_mode_e cur_mode;
  switch(mode)
  {
	case RT_WLAN_STATION:
		cur_mode = WF_INFRA_MODE;
		break;
	case RT_WLAN_AP:
		cur_mode = WF_MASTER_MODE;
		break;
	default:
		break;
  }
  if(plocal->work_mode == cur_mode)
  {
    return RT_EOK;
  }
  
  wf_local_cfg_set_work_mode(pnic_info, cur_mode);
  
  wf_mlme_get_connect(pnic_info, &bConnect);
  if(bConnect)
  {
    wf_mlme_deauth(pnic_info, wf_true);
  }
  
  wf_mcu_set_op_mode(pnic_info, cur_mode);
  
  switch(cur_mode)
  {
  case WF_MASTER_MODE :
    cur_network->join_res = -1;
    wf_mlme_abort(pnic_info);
    break;
    
  case WF_MONITOR_MODE :
  case WF_INFRA_MODE :
  case WF_AUTO_MODE :
  default :
    break;
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_scan(struct rt_wlan_device *wlan, struct rt_scan_info *scan_info)
{
  nic_info_st *pnic_info = wlan->user_data;
  wf_bool is_connected, is_busy;
  
  wf_mlme_get_connect(pnic_info, &is_connected);
  if (is_connected)
  {
    wf_mlme_get_traffic_busy(pnic_info, &is_busy);
    if (is_busy)
    {
      wf_os_api_ind_scan_done(pnic_info, wf_true, WF_MLME_FRAMEWORK_WEXT);
      
      return RT_EOK;
    }
    wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                       NULL, 0, NULL, 0,
                       WF_MLME_FRAMEWORK_WEXT);
  }
  else
  {
    wf_wlan_ssid_t ssids[WF_SCAN_REQ_SSID_NUM];
    wf_memset(ssids, 0, sizeof(ssids));
    if(scan_info != NULL)
    {
      if (scan_info->ssid.len != 0)
      {
        int len = sizeof(scan_info->ssid);
        if(len > RT_WLAN_SSID_MAX_LENGTH)
        {
          len = RT_WLAN_SSID_MAX_LENGTH;
        }
        wf_memcpy(ssids[0].data, scan_info->ssid.val, scan_info->ssid.len);
        ssids[0].length = len;
        
        LOG_D("ssid = %s, ssid_len = %d", ssids[0].data, ssids[0].length);
        
        wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                           ssids, 1, NULL, 0,
                           WF_MLME_FRAMEWORK_WEXT);
      }
    }
    else
    {
      wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                         NULL, 0, NULL, 0,
                         WF_MLME_FRAMEWORK_WEXT);
    }
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_join(struct rt_wlan_device *wlan, struct rt_sta_info *sta_info)
{
  
  nic_info_st *pnic_info = wlan->user_data;
  sec_info_st *psec_info = pnic_info->sec_info;
  wf_u8 len;
  
  if (wf_local_cfg_get_work_mode(pnic_info) == WF_MASTER_MODE)
  {
    LOG_E("ap no support wf_wlan_join");
    return -RT_ERROR;
  }
  
#if WIRELESS_EXT <= 20
  len = sta_info->ssid.len - 1;
#else
  len = sta_info->ssid.len;
#endif
  if (len > 32)
  {
    LOG_E("ssid length %d too long", len);
    return -RT_ERROR;
  }
  
  if (len == 32)
  {
    LOG_D("clear essid");
    return RT_EOK;
  }
  
  if (sta_info->ssid.len)
  {
    wf_wlan_mgmt_scan_que_for_rst_e scan_que_for_rst;
    wf_wlan_mgmt_scan_que_node_t *pscan_que_node;
    wf_wlan_ssid_t ssid;
    wf_u8 *pbssid = NULL;
    
    wf_memcpy(ssid.data, sta_info->ssid.val, ssid.length = len);
    ssid.data[ssid.length] = '\0';
    
    wf_wlan_mgmt_scan_que_for_begin(pnic_info, pscan_que_node)
    {
      if (wf_wlan_is_same_ssid(&pscan_que_node->ssid, &ssid))
      {
        pbssid = pscan_que_node->bssid;
        break;
      }
    }
    wf_wlan_mgmt_scan_que_for_end(scan_que_for_rst);
    
    if (scan_que_for_rst == WF_WLAN_MGMT_SCAN_QUE_FOR_RST_FAIL)
    {
      LOG_W("scan queue for each fail");
      return -RT_ERROR;
    }
    else
    {
      wf_bool is_connected;
      wf_mlme_get_connect(pnic_info, &is_connected);
      if (is_connected)
      {
        if (pbssid &&
            wf_80211_is_same_addr(wf_wlan_get_cur_bssid(pnic_info), pbssid))
        {
          LOG_D("the essid as same as the current associate ssid");
          wf_os_api_ind_connect(pnic_info, WF_MLME_FRAMEWORK_WEXT);
          return RT_EOK;
        }
      }
      
      if (psec_info->dot11AuthAlgrthm == _NO_PRIVACY_)
      {
        wf_memset(pnic_info->sec_info, 0x0, sizeof(sec_info_st));
      }
      else if (scan_que_for_rst == WF_WLAN_MGMT_SCAN_QUE_FOR_RST_BREAK)
      {
        wf_80211_mgmt_ie_t *pies =
          (void *)((struct beacon_ie *)pscan_que_node->ies)->variable;
        wf_u16 ies_len = pscan_que_node->ie_len -
          WF_OFFSETOF(struct beacon_ie, variable);
        if (!wf_is_8021x_auth(pies, ies_len) &&
            psec_info->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)
        {
          wf_memset(pnic_info->sec_info, 0x0, sizeof(sec_info_st));
        }
      }
      
      /* start connection */
      wf_mlme_conn_start(pnic_info, pbssid, &ssid,
                         WF_MLME_FRAMEWORK_WEXT, wf_true);
    }
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_softap(struct rt_wlan_device *wlan, struct rt_ap_info *ap_info)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_disconnect(struct rt_wlan_device *wlan)
{
  nic_info_st *pnic_info = wlan->user_data;
  wf_mlme_deassoc(pnic_info);
  return RT_EOK;
}

static rt_err_t wf_wlan_ap_stop(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_ap_deauth(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  return RT_EOK;
}

static rt_err_t wf_wlan_scan_stop(struct rt_wlan_device *wlan)
{
	
  nic_info_st *pnic_info = wlan->user_data;
  wf_scan_stop(pnic_info);
  return RT_EOK;
}

static int wf_wlan_get_rssi(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_set_powersave(struct rt_wlan_device *wlan, int level)
{
  return RT_EOK;
}

static int wf_wlan_get_powersave(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_promisc(struct rt_wlan_device *wlan, rt_bool_t start)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_filter(struct rt_wlan_device *wlan, struct rt_wlan_filter *filter)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_mgmt_filter(struct rt_wlan_device *wlan, rt_bool_t start)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_set_channel(struct rt_wlan_device *wlan, int channel)
{
	
  nic_info_st *pnic_info = wlan->user_data;
  wf_wlan_mgmt_info_t *pwlan_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *pcur_network = &pwlan_info->cur_network;
  
  pcur_network->channel = channel;
  wf_hw_info_set_channnel_bw(pnic_info, pcur_network->channel, pcur_network->bw, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
  return RT_EOK;
}

static int wf_wlan_get_channel(struct rt_wlan_device *wlan)
{
  nic_info_st *pnic_info = wlan->user_data;
  wf_wlan_mgmt_info_t *pwlan_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *pcur_network = &pwlan_info->cur_network;
  
  return pcur_network->channel;
}

static rt_err_t wf_wlan_set_country(struct rt_wlan_device *wlan, rt_country_code_t country_code)
{
  nic_info_st *pnic_info = wlan->user_data;
  hw_info_st *phw_info = pnic_info->hw_info;
  phw_info->channel_plan = country_code;
  
  channel_init(pnic_info);
  return RT_EOK;
}

static rt_country_code_t wf_wlan_get_country(struct rt_wlan_device *wlan)
{
  nic_info_st *pnic_info = wlan->user_data;

  hw_info_st *phw_info = pnic_info->hw_info;
  return (rt_country_code_t)phw_info->channel_plan;
}

static rt_err_t wf_wlan_set_mac(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  nic_info_st *pnic_info = wlan->user_data;

  hw_info_st *phw_info = pnic_info->hw_info;
  wf_memcpy(phw_info->macAddr,mac,6);
  return RT_EOK;
}

static rt_err_t wf_wlan_get_mac(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  
  nic_info_st *pnic_info = wlan->user_data;
  hw_info_st *phw_info = pnic_info->hw_info;
  wf_memcpy(mac,phw_info->macAddr,6);
  return RT_EOK;
}

static int wf_wlan_recv(struct rt_wlan_device *wlan, void *buff, int len)
{
  return RT_EOK;
}

static int wf_wlan_send(struct rt_wlan_device *wlan, void *buff, int len)
{
#if 0
  nic_info_st *nic_info = wlan->user_data;
  struct xmit_frame *pxframe = NULL;
  tx_info_st *tx_info = nic_info->tx_info;
  struct xmit_buf *pxmitbuf = NULL;
  wf_s32 res = wf_false;
  wf_bool bTxQueue_empty;
  int addbaRet = -1;
  wf_bool bRet = wf_false;
  mlme_info_t *mlme_info = nic_info->mlme_info;
  hw_info_st *hw_info = nic_info->hw_info;
  struct sk_buff *skb;
  
  while (1)
  {
    if(WF_CANNOT_RUN(nic_info))
    {
      return -1;
    }
    
    if(tx_work_need_stop(nic_info)) {
      LOG_D("wf_tx_send_need_stop, just return it");
      return -1;
    }
    
    bTxQueue_empty = wf_que_is_empty(&tx_info->pending_frame_queue);
    if (bTxQueue_empty == wf_true)
    {
      //LOG_D("tx_work_mpdu_xmit break, tx queue empty");
      break;
    }
    
    pxmitbuf = wf_xmit_buf_new(tx_info);
    if (pxmitbuf == NULL)
    {
      //LOG_D("tx_work_mpdu_xmit break, no xmitbuf");
      break;
    }
    
    pxframe = wf_tx_data_getqueue(tx_info);
    if (pxframe)
    {
      pxframe->pxmitbuf = pxmitbuf;
      pxframe->buf_addr = pxmitbuf->pbuf;
      pxmitbuf->priv_data = pxframe;
      
      /* error msdu */
      if (pxframe->priority > 15)
      {
        wf_xmit_buf_delete(tx_info, pxmitbuf);
        wf_xmit_frame_delete(tx_info, pxframe);
        dev_kfree_skb_any(pxframe->pkt);
        pxframe->pkt = NULL;
        LOG_E("[%s]:error msdu", __func__);
        break;
      }
      
      /* BA start check */
      if (mlme_info->link_info.num_tx_ok_in_period_with_tid[pxframe->qsel] > 100 && (hw_info->ba_enable == wf_true))
      {
        addbaRet = wf_action_frame_add_ba_request(nic_info, pxframe);
        if (addbaRet == 0)
        {
          LOG_I("Send Msg to MLME for starting BA!!");
          wf_xmit_buf_delete(tx_info, pxmitbuf);
          break;
        }
      }
      
      /* msdu2mpdu */
      if (pxframe->pkt != NULL)
      {
        skb = (struct sk_buff *)pxframe->pkt;
        
        res = wf_tx_msdu_to_mpdu(nic_info, pxframe, skb->data, skb->len);
        
        dev_kfree_skb_any(pxframe->pkt);
        pxframe->pkt = NULL;
      }
      
      /* send to hif tx queue */
      if (res == wf_true)
      {
        bRet = mpdu_insert_sending_queue(nic_info, pxframe, wf_false);
        if (bRet == wf_false)
        {
          wf_xmit_buf_delete(tx_info, pxmitbuf);
        }
        else
        {
          wf_xmit_frame_delete(tx_info, pxframe);
        }
      }
      else
      {
        LOG_E("wf_tx_msdu_to_mpdu error!!");
        
        wf_xmit_buf_delete(tx_info, pxmitbuf);
        wf_xmit_frame_delete(tx_info, pxframe);
      } 
    }
    else
    {
      wf_xmit_buf_delete(tx_info, pxmitbuf);
      break;
    }
  }
  
  /* check tx resource */
  bRet = wf_need_wake_queue(nic_info);
  if (bRet == wf_true)
  {
    LOG_W("<<<<ndev tx start queue");
    ndev_tx_resource_enable(nic_info->ndev, pxframe->pkt);
  }
 #endif
  return RT_EOK;
}


const static struct rt_wlan_dev_ops ops =
{
  .wlan_init          = wf_wlan_init,
  .wlan_mode          = wf_wlan_mode,
  .wlan_scan          = wf_wlan_scan,
  .wlan_join          = wf_wlan_join,
  .wlan_softap        = wf_wlan_softap,
  .wlan_disconnect    = wf_wlan_disconnect,
  .wlan_ap_stop       = wf_wlan_ap_stop,
  .wlan_ap_deauth     = wf_wlan_ap_deauth,
  .wlan_scan_stop     = wf_wlan_scan_stop,
  .wlan_get_rssi      = wf_wlan_get_rssi,
  .wlan_set_powersave = wf_wlan_set_powersave,
  .wlan_get_powersave = wf_wlan_get_powersave,
  .wlan_cfg_promisc   = wf_wlan_cfg_promisc,
  .wlan_cfg_filter    = wf_wlan_cfg_filter,
  .wlan_cfg_mgnt_filter = wf_wlan_cfg_mgmt_filter,
  .wlan_set_channel   = wf_wlan_set_channel,
  .wlan_get_channel   = wf_wlan_get_channel,
  .wlan_set_country   = wf_wlan_set_country,
  .wlan_get_country   = wf_wlan_get_country,
  .wlan_set_mac       = wf_wlan_set_mac,
  .wlan_get_mac       = wf_wlan_get_mac,
  .wlan_recv          = wf_wlan_recv,
  .wlan_send          = wf_wlan_send,
};

int rt_wlan_register (nic_info_st *pnic_info, const char *name)
{
  rt_err_t ret;
  struct rt_wlan_device *wlan_dev;
  
  wlan_dev = wf_kzalloc(sizeof(struct rt_wlan_device));
  if(NULL == wlan_dev) {
    LOG_E("cann't malloc memmory for wlan dev");
    return -1;
  }
  
  /* register wlan device */
  ret = rt_wlan_dev_register(wlan_dev, name, &ops, 0, pnic_info);
  if (ret != RT_EOK)
  {
    LOG_E("register wlan dev error");
    return ret;
  }
  
  return 0;
}

int rt_wlan_shutdown(nic_info_st *pnic_info)
{
  LOG_I("enter %s", __func__);
  if (pnic_info == NULL)
  {
    return 0;
  }
  
  nic_shutdown(pnic_info);
  
  return 0;
}

int rt_wlan_unregister (nic_info_st *pnic_info, const char *name)
{
  LOG_E("NO  support for wlan dev unregister");
  return 0;
}

