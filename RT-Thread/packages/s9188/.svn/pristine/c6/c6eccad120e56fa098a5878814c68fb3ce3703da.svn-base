#include "common.h"
#include "wf_wlan_dev.h"
#include "trx/tx_rtthread.h"
#include "wf_debug.h"

static wf_bool wf_is_8021x_auth (wf_80211_mgmt_ie_t *pies, wf_u16 ies_len)
{
    wf_80211_mgmt_ie_t *pie;

    if (!wf_80211_mgmt_ies_search(pies, ies_len,
                                  WF_80211_MGMT_EID_RSN, &pie))
    {
        LOG_D("RSN");
        return wf_true;
    }

    if (!wf_80211_mgmt_ies_search(pies, ies_len,
                                  WF_80211_MGMT_EID_VENDOR_SPECIFIC, &pie))
    {
        wf_u32 pmulticast_cipher, punicast_cipher;
        if (!wf_80211_mgmt_wpa_parse(pie,
                                     WF_OFFSETOF(wf_80211_mgmt_ie_t, data) + pie->len,
                                     &pmulticast_cipher,
                                     &punicast_cipher))
        {
            LOG_D("WPA");
            return wf_true;
        }
    }

    LOG_D("NO 8021X");
    return wf_false;
}


static rt_err_t wf_wlan_init(struct rt_wlan_device *wlan)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  hw_info_st *hw_info;
  
  LOG_D("F:%s L:%d", __FUNCTION__, __LINE__);
  
  if (nic_init(pnic_info)<0)
    return -1;
  
  tx_work_init(wlan);
  
  hw_info = (hw_info_st *)pnic_info->hw_info;
  if (hw_info)
  {
    if((0 == hw_info->macAddr[0]) && (0 == hw_info->macAddr[1]) && (0 == hw_info->macAddr[2])
       && (0 == hw_info->macAddr[3]) && (0 == hw_info->macAddr[4]) && (0 == hw_info->macAddr[5]))
    {
      LOG_E("[%s]: no valid mac addr", __func__);
      return -1;
    }
    
    LOG_I("efuse_macaddr:"WF_MAC_FMT,WF_MAC_ARG(hw_info->macAddr));
    if(wlan_priv->nic->nic_num == 0)
    {
      memcpy(wlan_priv->hw_addr, hw_info->macAddr, WF_ETH_ALEN);
      //wf_mcu_hw_var_set_macaddr(ndev_priv->nic,ndev->dev_addr);
    }
    else if(wlan_priv->nic->nic_num == 1)
    {
      hw_info->macAddr[0] = hw_info->macAddr[0] + 0x2;
      memcpy(wlan_priv->hw_addr, hw_info->macAddr, WF_ETH_ALEN);
      //wf_mcu_hw_var_set_macaddr(ndev_priv->nic,ndev->dev_addr);
    }
    wf_mcu_hw_var_set_macaddr(wlan_priv->nic,wlan_priv->hw_addr);
  } 
  
  return RT_EOK;
}

static rt_err_t wf_wlan_mode(struct rt_wlan_device *wlan, rt_wlan_mode_t mode)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  
  LOG_D("F:%s L:%d mode:%d", __FUNCTION__, __LINE__, mode);
  
  local_info_st * plocal = (local_info_st *)pnic_info->local_info;
  wf_bool bConnect = wf_false;
  wf_wlan_mgmt_info_t *wlan_mgmt_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *cur_network = &wlan_mgmt_info->cur_network;
  sys_work_mode_e cur_mode;
  switch(mode)
  {
	case RT_WLAN_STATION:
		cur_mode = WF_INFRA_MODE;
		break;
	case RT_WLAN_AP:
		cur_mode = WF_MASTER_MODE;
		break;
	default:
		break;
  }
//  if(plocal->work_mode == cur_mode)
//  {
//    return RT_EOK;
//  }
  
  wf_local_cfg_set_work_mode(pnic_info, cur_mode);
  
  wf_mlme_get_connect(pnic_info, &bConnect);
  if(bConnect)
  {
    wf_mlme_deauth(pnic_info, wf_true);
  }
  
  wf_mcu_set_op_mode(pnic_info, cur_mode);
  
  switch(cur_mode)
  {
  case WF_MASTER_MODE :
    cur_network->join_res = -1;
    wf_mlme_abort(pnic_info);
    break;
    
  case WF_MONITOR_MODE :
  case WF_INFRA_MODE :
  case WF_AUTO_MODE :
  default :
    break;
  }
  
  LOG_I("wlan dev open");
  if (nic_enable(pnic_info) == WF_RETURN_FAIL)
  {
    return -1;
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_scan(struct rt_wlan_device *wlan, struct rt_scan_info *scan_info)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  
  wf_bool is_connected, is_busy;
  
  wf_mlme_get_connect(pnic_info, &is_connected);
  if (is_connected)
  {
    wf_mlme_get_traffic_busy(pnic_info, &is_busy);
    if (is_busy)
    {
      wf_os_api_ind_scan_done(pnic_info, wf_true, WF_MLME_FRAMEWORK_WEXT);
      
      return RT_EOK;
    }
    wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                       NULL, 0, NULL, 0,
                       WF_MLME_FRAMEWORK_WEXT);
  }
  else
  {
    wf_wlan_ssid_t ssids[WF_SCAN_REQ_SSID_NUM];
    wf_memset(ssids, 0, sizeof(ssids));
    if(scan_info != NULL)
    {
      if (scan_info->ssid.len != 0)
      {
        int len = sizeof(scan_info->ssid);
        if(len > RT_WLAN_SSID_MAX_LENGTH)
        {
          len = RT_WLAN_SSID_MAX_LENGTH;
        }
        wf_memcpy(ssids[0].data, scan_info->ssid.val, scan_info->ssid.len);
        ssids[0].length = len;
        
        LOG_D("ssid = %s, ssid_len = %d", ssids[0].data, ssids[0].length);
        
        wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                           ssids, 1, NULL, 0,
                           WF_MLME_FRAMEWORK_WEXT);
      }
    }
    else
    {
      wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                         NULL, 0, NULL, 0,
                         WF_MLME_FRAMEWORK_WEXT);
    }
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_join(struct rt_wlan_device *wlan, struct rt_sta_info *sta_info)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  sec_info_st *psec_info = pnic_info->sec_info;
  wf_u8 len;
  
  if (wf_local_cfg_get_work_mode(pnic_info) == WF_MASTER_MODE)
  {
    LOG_E("ap no support wf_wlan_join");
    return -RT_ERROR;
  }
  
#if WIRELESS_EXT <= 20
  len = sta_info->ssid.len - 1;
#else
  len = sta_info->ssid.len;
#endif
  if (len > 32)
  {
    LOG_E("ssid length %d too long", len);
    return -RT_ERROR;
  }
  
  if (len == 32)
  {
    LOG_D("clear essid");
    return RT_EOK;
  }
  
  if (sta_info->ssid.len)
  {
    wf_wlan_mgmt_scan_que_for_rst_e scan_que_for_rst;
    wf_wlan_mgmt_scan_que_node_t *pscan_que_node;
    wf_wlan_ssid_t ssid;
    wf_u8 *pbssid = NULL;
    
    wf_memcpy(ssid.data, sta_info->ssid.val, ssid.length = len);
    ssid.data[ssid.length] = '\0';
    
    wf_wlan_mgmt_scan_que_for_begin(pnic_info, pscan_que_node)
    {
      if (wf_wlan_is_same_ssid(&pscan_que_node->ssid, &ssid))
      {
        pbssid = pscan_que_node->bssid;
        break;
      }
    }
    wf_wlan_mgmt_scan_que_for_end(scan_que_for_rst);
    
    if (scan_que_for_rst == WF_WLAN_MGMT_SCAN_QUE_FOR_RST_FAIL)
    {
      LOG_W("scan queue for each fail");
      return -RT_ERROR;
    }
    else
    {
      wf_bool is_connected;
      wf_mlme_get_connect(pnic_info, &is_connected);
      if (is_connected)
      {
        if (pbssid &&
            wf_80211_is_same_addr(wf_wlan_get_cur_bssid(pnic_info), pbssid))
        {
          LOG_D("the essid as same as the current associate ssid");
          wf_os_api_ind_connect(pnic_info, WF_MLME_FRAMEWORK_WEXT);
          return RT_EOK;
        }
      }
      
      if (psec_info->dot11AuthAlgrthm == _NO_PRIVACY_)
      {
        wf_memset(pnic_info->sec_info, 0x0, sizeof(sec_info_st));
      }
      else if (scan_que_for_rst == WF_WLAN_MGMT_SCAN_QUE_FOR_RST_BREAK)
      {
        wf_80211_mgmt_ie_t *pies =
          (void *)((struct beacon_ie *)pscan_que_node->ies)->variable;
        wf_u16 ies_len = pscan_que_node->ie_len -
          WF_OFFSETOF(struct beacon_ie, variable);
        if (!wf_is_8021x_auth(pies, ies_len) &&
            psec_info->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)
        {
          wf_memset(pnic_info->sec_info, 0x0, sizeof(sec_info_st));
        }
      }
      
      /* start connection */
      wf_mlme_conn_start(pnic_info, pbssid, &ssid,
                         WF_MLME_FRAMEWORK_WEXT, wf_true);
    }
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_softap(struct rt_wlan_device *wlan, struct rt_ap_info *ap_info)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_disconnect(struct rt_wlan_device *wlan)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  
  wf_mlme_deassoc(pnic_info);
  return RT_EOK;
}

static rt_err_t wf_wlan_ap_stop(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_ap_deauth(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  return RT_EOK;
}

static rt_err_t wf_wlan_scan_stop(struct rt_wlan_device *wlan)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  
  wf_scan_stop(pnic_info);
  return RT_EOK;
}

static int wf_wlan_get_rssi(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_set_powersave(struct rt_wlan_device *wlan, int level)
{
  return RT_EOK;
}

static int wf_wlan_get_powersave(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_promisc(struct rt_wlan_device *wlan, rt_bool_t start)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_filter(struct rt_wlan_device *wlan, struct rt_wlan_filter *filter)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_mgmt_filter(struct rt_wlan_device *wlan, rt_bool_t start)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_set_channel(struct rt_wlan_device *wlan, int channel)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  
  wf_wlan_mgmt_info_t *pwlan_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *pcur_network = &pwlan_info->cur_network;
  
  pcur_network->channel = channel;
  wf_hw_info_set_channnel_bw(pnic_info, pcur_network->channel, pcur_network->bw, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
  return RT_EOK;
}

static int wf_wlan_get_channel(struct rt_wlan_device *wlan)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  
  wf_wlan_mgmt_info_t *pwlan_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *pcur_network = &pwlan_info->cur_network;
  
  return pcur_network->channel;
}

static rt_err_t wf_wlan_set_country(struct rt_wlan_device *wlan, rt_country_code_t country_code)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  
  hw_info_st *phw_info = pnic_info->hw_info;
  phw_info->channel_plan = country_code;
  
  channel_init(pnic_info);
  return RT_EOK;
}

static rt_country_code_t wf_wlan_get_country(struct rt_wlan_device *wlan)
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;

  hw_info_st *phw_info = pnic_info->hw_info;
  return (rt_country_code_t)phw_info->channel_plan;
}

static rt_err_t wf_wlan_set_mac(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;

  hw_info_st *phw_info = pnic_info->hw_info;
  wf_memcpy(phw_info->macAddr,mac,6);
  return RT_EOK;
}

static rt_err_t wf_wlan_get_mac(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  
  hw_info_st *phw_info = pnic_info->hw_info;
  wf_memcpy(mac,phw_info->macAddr,6);
  return RT_EOK;
}

static int wf_wlan_recv(struct rt_wlan_device *wlan, void *buff, int len)
{
  return RT_EOK;
}

static int wf_wlan_send(struct rt_wlan_device *wlan, void *buff, int len)
{
  wf_bool bRet = wf_false;
  struct rt_wlan_priv *wlan_priv = wlan->user_data;
  nic_info_st *pnic_info = wlan_priv->nic;
  struct pbuf *p = (struct pbuf *)buff;
  wf_u8 *frame;
  
  if(!p)
  {
    return -RT_ERROR;
  }
  
  if(WF_CANNOT_RUN(wlan_priv->nic))
  {
    return -RT_EIO;
  }
  
  if (wlan_priv->nic->tx_info == NULL)
  {
    return -RT_EIO;
  }
  
  if (wf_mlme_check_mode(wlan_priv->nic, WF_MONITOR_MODE) == wf_true)
  {
    //work_monitor_tx_entry(pnetdev, (struct sk_buff *)pkt);
  }
  else
  {
    if(wf_false == wf_tx_data_check(wlan_priv->nic))
    {
      ;
    }
    else
    {
       /* tx resource check */
      bRet = wf_need_stop_queue(wlan_priv->nic);
      if (bRet == wf_true) {
        LOG_W(">>>>wlan dev tx stop queue");
        return -RT_ENOMEM;
      }
      
      /* actually xmit */
      frame = rt_malloc(p->tot_len);
      if (frame == RT_NULL)
      {
        LOG_E("F:%s L:%d malloc out_buf fail\n", __FUNCTION__, __LINE__);
        return -RT_ENOMEM;
      }
      /*copy pbuf -> data dat*/
      pbuf_copy_partial(p, frame, p->tot_len, 0);
      if(0 != wf_tx_msdu(wlan_priv->nic, frame, p->tot_len, frame))
      {
        rt_free(frame);
      }
      else
      {
        tx_work_wake(wlan);
      }
    }
  }
  
  return RT_EOK;
}


const static struct rt_wlan_dev_ops ops =
{
  .wlan_init          = wf_wlan_init,
  .wlan_mode          = wf_wlan_mode,
  .wlan_scan          = wf_wlan_scan,
  .wlan_join          = wf_wlan_join,
  .wlan_softap        = wf_wlan_softap,
  .wlan_disconnect    = wf_wlan_disconnect,
  .wlan_ap_stop       = wf_wlan_ap_stop,
  .wlan_ap_deauth     = wf_wlan_ap_deauth,
  .wlan_scan_stop     = wf_wlan_scan_stop,
  .wlan_get_rssi      = wf_wlan_get_rssi,
  .wlan_set_powersave = wf_wlan_set_powersave,
  .wlan_get_powersave = wf_wlan_get_powersave,
  .wlan_cfg_promisc   = wf_wlan_cfg_promisc,
  .wlan_cfg_filter    = wf_wlan_cfg_filter,
  .wlan_cfg_mgnt_filter = wf_wlan_cfg_mgmt_filter,
  .wlan_set_channel   = wf_wlan_set_channel,
  .wlan_get_channel   = wf_wlan_get_channel,
  .wlan_set_country   = wf_wlan_set_country,
  .wlan_get_country   = wf_wlan_get_country,
  .wlan_set_mac       = wf_wlan_set_mac,
  .wlan_get_mac       = wf_wlan_get_mac,
  .wlan_recv          = wf_wlan_recv,
  .wlan_send          = wf_wlan_send,
};

int rt_wlan_register (nic_info_st *pnic_info, const char *name)
{
  rt_err_t ret;
  struct rt_wlan_device *wlan_dev;
  struct rt_wlan_priv   *wlan_priv;
  
  wlan_dev = wf_kzalloc(sizeof(struct rt_wlan_device));
  if(NULL == wlan_dev) {
    LOG_E("cann't malloc memmory for wlan dev");
    return -1;
  }
  
  wlan_priv = wf_kzalloc(sizeof(struct rt_wlan_priv));
  if(NULL == wlan_priv) {
    LOG_E("cann't malloc memmory for wlan priv");
    return -1;
  }
  
  wlan_priv->nic = pnic_info;
  pnic_info->ndev = wlan_dev;
  
  /* register wlan device */
  ret = rt_wlan_dev_register(wlan_dev, name, &ops, 0, wlan_priv);
  if (ret != RT_EOK)
  {
    LOG_E("register wlan dev error");
    return ret;
  }
  
  return 0;
}

int rt_wlan_shutdown(nic_info_st *pnic_info)
{
  LOG_I("enter %s", __func__);
  if (pnic_info == NULL)
  {
    return 0;
  }
  
  nic_shutdown(pnic_info);
  
  return 0;
}

int rt_wlan_unregister (nic_info_st *pnic_info)
{
  LOG_E("NO  support for wlan dev unregister");
  return 0;
}

