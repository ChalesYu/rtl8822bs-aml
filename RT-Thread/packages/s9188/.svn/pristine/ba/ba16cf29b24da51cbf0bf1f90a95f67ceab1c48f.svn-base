#include "common.h"
#include "wf_debug.h"


static rt_err_t wf_wlan_init(struct rt_wlan_device *wlan)
{
  LOG_D("F:%s L:%d", __FUNCTION__, __LINE__);
  return RT_EOK;
}

static rt_err_t wf_wlan_mode(struct rt_wlan_device *wlan, rt_wlan_mode_t mode)
{
  nic_info_st *nic_info = wlan->user_data;
  
  LOG_D("F:%s L:%d mode:%d", __FUNCTION__, __LINE__, mode);
  
  ndev_priv_st *pndev_priv = netdev_priv(ndev);
  nic_info_st *pnic_info = pndev_priv->nic;
  local_info_st * plocal = (local_info_st *)pnic_info->local_info;
  wf_bool bConnect = wf_false;
  wf_wlan_mgmt_info_t *wlan_mgmt_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *cur_network = &wlan_mgmt_info->cur_network;
  
  if(plocal->work_mode == mode)
  {
    return RT_EOK;
  }
  
  wf_local_cfg_set_work_mode(pnic_info, mode);
  
  wf_mlme_get_connect(pnic_info, &bConnect);
  if(bConnect)
  {
    wf_mlme_deauth(pnic_info, wf_true);
  }
  
  wf_mcu_set_op_mode(pnic_info, mode);
  
  switch(mode)
  {
  case WF_MASTER_MODE :
    cur_network->join_res = -1;
    wf_mlme_abort(pnic_info);
    break;
    
  case WF_MONITOR_MODE :
  case WF_INFRA_MODE :
  case WF_AUTO_MODE :
  default :
    break;
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_scan(struct rt_wlan_device *wlan, struct rt_scan_info *scan_info)
{
  ndev_priv_st *pndev_priv = netdev_priv(ndev);
  nic_info_st *pnic_info = pndev_priv->nic;
  wf_bool is_connected, is_busy;
  
  wf_mlme_get_connect(pndev_priv->nic, &is_connected);
  if (is_connected)
  {
    wf_mlme_get_traffic_busy(pndev_priv->nic, &is_busy);
    if (is_busy)
    {
      wf_os_api_ind_scan_done(pnic_info, wf_true, WF_MLME_FRAMEWORK_WEXT);
      
      return RT_EOK;
    }
    wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                       NULL, 0, NULL, 0,
                       WF_MLME_FRAMEWORK_WEXT);
  }
  else
  {
    wf_wlan_ssid_t ssids[WF_SCAN_REQ_SSID_NUM];
    wf_memset(ssids, 0, sizeof(ssids));
    if(scan_info != NULL)
    {
      if (scan_info->ssid != NULL)
      {
        int len = sizeof(scan_info->ssid);
        if(len > RT_WLAN_SSID_MAX_LENGTH)
        {
          len = RT_WLAN_SSID_MAX_LENGTH;
        }
        wf_memcpy(ssids[0].data, scan_info->ssid, len);
        ssids[0].length = len;
        
        IW_FUNC_DBG("ssid = %s, ssid_len = %d", ssids[0].data, ssids[0].length);
        
        wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                           ssids, 1, NULL, 0,
                           WF_MLME_FRAMEWORK_WEXT);
      }
    }
    else
    {
      wf_mlme_scan_start(pnic_info, SCAN_TYPE_ACTIVE,
                         NULL, 0, NULL, 0,
                         WF_MLME_FRAMEWORK_WEXT);
    }
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_join(struct rt_wlan_device *wlan, struct rt_sta_info *sta_info)
{
  
  ndev_priv_st *pndev_priv = netdev_priv(ndev);
  nic_info_st *pnic_info = pndev_priv->nic;
  sec_info_st *psec_info = pnic_info->sec_info;
  wf_u8 len;
  
  if (wf_local_cfg_get_work_mode(pnic_info) == WF_MASTER_MODE)
  {
    IW_FUNC_ERROR("ap no support wf_wlan_join");
    return -RT_ERROR;
  }
  
#if WIRELESS_EXT <= 20
  len = sta_info->ssid.len - 1;
#else
  len = sta_info->ssid.len;
#endif
  if (len > 32)
  {
    IW_FUNC_ERROR("ssid length %d too long", len);
    return -RT_ERROR;
  }
  
  if (len == 32)
  {
    IW_FUNC_DBG("clear essid");
    return RT_EOK;
  }
  
  if (sta_info->ssid.len)
  {
    wf_wlan_mgmt_scan_que_for_rst_e scan_que_for_rst;
    wf_wlan_mgmt_scan_que_node_t *pscan_que_node;
    wf_wlan_ssid_t ssid;
    wf_u8 *pbssid = NULL;
    
    wf_memcpy(ssid.data, sta_info->ssid.val, ssid.length = len);
    ssid.data[ssid.length] = '\0';
    
    wf_wlan_mgmt_scan_que_for_begin(pnic_info, pscan_que_node)
    {
      if (wf_wlan_is_same_ssid(&pscan_que_node->ssid, &ssid))
      {
        pbssid = pscan_que_node->bssid;
        break;
      }
    }
    wf_wlan_mgmt_scan_que_for_end(scan_que_for_rst);
    
    if (scan_que_for_rst == WF_WLAN_MGMT_SCAN_QUE_FOR_RST_FAIL)
    {
      IW_FUNC_WARN("scan queue for each fail");
      return -RT_ERROR;
    }
    else
    {
      wf_bool is_connected;
      wf_mlme_get_connect(pnic_info, &is_connected);
      if (is_connected)
      {
        if (pbssid &&
            wf_80211_is_same_addr(wf_wlan_get_cur_bssid(pnic_info), pbssid))
        {
          IW_FUNC_INFO("the essid as same as the current associate ssid");
          wf_os_api_ind_connect(pnic_info, WF_MLME_FRAMEWORK_WEXT);
          return RT_EOK;
        }
      }
      
      if (psec_info->dot11AuthAlgrthm == _NO_PRIVACY_)
      {
        wf_memset(pnic_info->sec_info, 0x0, sizeof(sec_info_st));
      }
      else if (scan_que_for_rst == WF_WLAN_MGMT_SCAN_QUE_FOR_RST_BREAK)
      {
        wf_80211_mgmt_ie_t *pies =
          (void *)((struct beacon_ie *)pscan_que_node->ies)->variable;
        wf_u16 ies_len = pscan_que_node->ie_len -
          WF_OFFSETOF(struct beacon_ie, variable);
        if (!is_8021x_auth(pies, ies_len) &&
            psec_info->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)
        {
          wf_memset(pnic_info->sec_info, 0x0, sizeof(sec_info_st));
        }
      }
      
      /* start connection */
      wf_mlme_conn_start(pnic_info, pbssid, &ssid,
                         WF_MLME_FRAMEWORK_WEXT, wf_true);
    }
  }
  
  return RT_EOK;
}

static rt_err_t wf_wlan_softap(struct rt_wlan_device *wlan, struct rt_ap_info *ap_info)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_disconnect(struct rt_wlan_device *wlan)
{
  wf_mlme_deassoc(pnic_info);
  return RT_EOK;
}

static rt_err_t wf_wlan_ap_stop(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_ap_deauth(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  return RT_EOK;
}

static rt_err_t wf_wlan_scan_stop(struct rt_wlan_device *wlan)
{
  wf_scan_stop(pnic_info);
  return RT_EOK;
}

static int wf_wlan_get_rssi(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_set_powersave(struct rt_wlan_device *wlan, int level)
{
  return RT_EOK;
}

static int wf_wlan_get_powersave(struct rt_wlan_device *wlan)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_promisc(struct rt_wlan_device *wlan, rt_bool_t start)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_filter(struct rt_wlan_device *wlan, struct rt_wlan_filter *filter)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_cfg_mgmt_filter(struct rt_wlan_device *wlan, rt_bool_t start)
{
  return RT_EOK;
}

static rt_err_t wf_wlan_set_channel(struct rt_wlan_device *wlan, int channel)
{
  wf_wlan_mgmt_info_t *pwlan_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *pcur_network = &pwlan_info->cur_network;
  
  pcur_network->channel = channel;
  wf_hw_info_set_channnel_bw(pnic_info, pcur_network->channel, pcur_network->bw, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
  return RT_EOK;
}

static int wf_wlan_get_channel(struct rt_wlan_device *wlan)
{
  wf_wlan_mgmt_info_t *pwlan_info = pnic_info->wlan_mgmt_info;
  wf_wlan_network_t *pcur_network = &pwlan_info->cur_network;
  
  return pcur_network->channel;
}

static rt_err_t wf_wlan_set_country(struct rt_wlan_device *wlan, rt_country_code_t country_code)
{
  hw_info_st *phw_info = pnic_info->hw_info;
  phw_info->channel_plan = country_code;
  
  channel_init(pnic_info);
  return RT_EOK;
}

static rt_country_code_t wf_wlan_get_country(struct rt_wlan_device *wlan)
{
  hw_info_st *phw_info = pnic_info->hw_info;
  return phw_info->channel_plan;
}

static rt_err_t wf_wlan_set_mac(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  hw_info_st *phw_info = pnic_info->hw_info;
  wf_memcpy(phw_info->macAddr,mac,6);
  return RT_EOK;
}

static rt_err_t wf_wlan_get_mac(struct rt_wlan_device *wlan, rt_uint8_t mac[])
{
  hw_info_st *phw_info = pnic_info->hw_info;
  wf_memcpy(mac,phw_info->macAddr,6);
  return RT_EOK;
}

static int wf_wlan_recv(struct rt_wlan_device *wlan, void *buff, int len)
{
  return RT_EOK;
}

static int wf_wlan_send(struct rt_wlan_device *wlan, void *buff, int len)
{
  struct xmit_frame *pxframe = NULL;
  tx_info_st *tx_info = nic_info->tx_info;
  struct xmit_buf *pxmitbuf = NULL;
  wf_s32 res = wf_false;
  wf_bool bTxQueue_empty;
  int addbaRet = -1;
  wf_bool bRet = wf_false;
  mlme_info_t *mlme_info = nic_info->mlme_info;
  hw_info_st *hw_info = nic_info->hw_info;
  struct sk_buff *skb;
  
  while (1)
  {
    if(WF_CANNOT_RUN(nic_info))
    {
      return -1;
    }
    
    if(tx_work_need_stop(nic_info)) {
      LOG_D("wf_tx_send_need_stop, just return it");
      return -1;
    }
    
    bTxQueue_empty = wf_que_is_empty(&tx_info->pending_frame_queue);
    if (bTxQueue_empty == wf_true)
    {
      //LOG_D("tx_work_mpdu_xmit break, tx queue empty");
      break;
    }
    
    pxmitbuf = wf_xmit_buf_new(tx_info);
    if (pxmitbuf == NULL)
    {
      //LOG_D("tx_work_mpdu_xmit break, no xmitbuf");
      break;
    }
    
    pxframe = wf_tx_data_getqueue(tx_info);
    if (pxframe)
    {
      pxframe->pxmitbuf = pxmitbuf;
      pxframe->buf_addr = pxmitbuf->pbuf;
      pxmitbuf->priv_data = pxframe;
      
      /* error msdu */
      if (pxframe->priority > 15)
      {
        wf_xmit_buf_delete(tx_info, pxmitbuf);
        wf_xmit_frame_delete(tx_info, pxframe);
        dev_kfree_skb_any(pxframe->pkt);
        pxframe->pkt = NULL;
        LOG_E("[%s]:error msdu", __func__);
        break;
      }
      
      /* BA start check */
      if (mlme_info->link_info.num_tx_ok_in_period_with_tid[pxframe->qsel] > 100 && (hw_info->ba_enable == wf_true))
      {
        addbaRet = wf_action_frame_add_ba_request(nic_info, pxframe);
        if (addbaRet == 0)
        {
          LOG_I("Send Msg to MLME for starting BA!!");
          wf_xmit_buf_delete(tx_info, pxmitbuf);
          break;
        }
      }
      
      /* msdu2mpdu */
      if (pxframe->pkt != NULL)
      {
        skb = (struct sk_buff *)pxframe->pkt;
        
        res = wf_tx_msdu_to_mpdu(nic_info, pxframe, skb->data, skb->len);
        
        dev_kfree_skb_any(pxframe->pkt);
        pxframe->pkt = NULL;
      }
      
      /* send to hif tx queue */
      if (res == wf_true)
      {
        bRet = mpdu_insert_sending_queue(nic_info, pxframe, wf_false);
        if (bRet == wf_false)
        {
          wf_xmit_buf_delete(tx_info, pxmitbuf);
        }
        else
        {
          wf_xmit_frame_delete(tx_info, pxframe);
        }
      }
      else
      {
        LOG_E("wf_tx_msdu_to_mpdu error!!");
        
        wf_xmit_buf_delete(tx_info, pxmitbuf);
        wf_xmit_frame_delete(tx_info, pxframe);
      } 
    }
    else
    {
      wf_xmit_buf_delete(tx_info, pxmitbuf);
      break;
    }
  }
  
  /* check tx resource */
  bRet = wf_need_wake_queue(nic_info);
  if (bRet == wf_true)
  {
    LOG_W("<<<<ndev tx start queue");
    ndev_tx_resource_enable(nic_info->ndev, pxframe->pkt);
  }
  
  return RT_EOK;
}


const static struct rt_wlan_dev_ops ops =
{
  .wlan_init          = wf_wlan_init,
  .wlan_mode          = wf_wlan_mode,
  .wlan_scan          = wf_wlan_scan,
  .wlan_join          = wf_wlan_join,
  .wlan_softap        = wf_wlan_softap,
  .wlan_disconnect    = wf_wlan_disconnect,
  .wlan_ap_stop       = wf_wlan_ap_stop,
  .wlan_ap_deauth     = wf_wlan_ap_deauth,
  .wlan_scan_stop     = wf_wlan_scan_stop,
  .wlan_get_rssi      = wf_wlan_get_rssi,
  .wlan_set_powersave = wf_wlan_set_powersave,
  .wlan_get_powersave = wf_wlan_get_powersave,
  .wlan_cfg_promisc   = wf_wlan_cfg_promisc,
  .wlan_cfg_filter    = wf_wlan_cfg_filter,
  .wlan_cfg_mgnt_filter = wf_wlan_cfg_mgmt_filter,
  .wlan_set_channel   = wf_wlan_set_channel,
  .wlan_get_channel   = wf_wlan_get_channel,
  .wlan_set_country   = wf_wlan_set_country,
  .wlan_get_country   = wf_wlan_get_country,
  .wlan_set_mac       = wf_wlan_set_mac,
  .wlan_get_mac       = wf_wlan_get_mac,
  .wlan_recv          = wf_wlan_recv,
  .wlan_send          = wf_wlan_send,
};

int rt_wlan_register (nic_info_st *pnic_info, const char *name)
{
  rt_err_t ret;
  struct rt_wlan_device *wlan_dev;
  
  wlan_dev = wf_kzalloc(sizeof(struct rt_wlan_device));
  if(NULL == wlan_dev) {
    LOG_E("cann't malloc memmory for wlan dev");
    return -1;
  }
  
  /* register wlan device */
  ret = rt_wlan_dev_register(wlan_dev, name, &ops, 0, pnic_info);
  if (ret != RT_EOK)
  {
    LOG_E("register wlan dev error");
    return ret;
  }
  
  return 0;
}

int rt_wlan_shutdown(nic_info_st *pnic_info)
{
  LOG_I("enter %s", __func__);
  if (pnic_info == NULL)
  {
    return 0;
  }
  
  nic_shutdown(pnic_info);
  
  return 0;
}

int rt_wlan_unregister (nic_info_st *pnic_info, const char *name)
{
  LOG_E("NO  support for wlan dev unregister");
  return 0;
}

