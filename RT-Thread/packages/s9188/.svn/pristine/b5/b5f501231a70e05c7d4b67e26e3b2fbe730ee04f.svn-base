#include "common.h"
#include "wf_debug.h"

#ifdef WF_CONFIG_P2P
#define WF_PUBLIC_ACTION_IE_OFFSET (8)

#if 1
#define P2P_FRAME_DBG(fmt, ...)      LOG_D("P2P_FRAME[%s:%d]"fmt, __func__,__LINE__, ##__VA_ARGS__)
#define P2P_FRAME_ARRAY(data, len)   log_array(data, len)
#else
#define P2P_FRAME_DBG(fmt, ...)
#define P2P_FRAME_ARRAY(data, len)
#endif
#define P2P_FRAME_INFO(fmt, ...)     LOG_I("P2P_FRAME[%s:%d]"fmt, __func__,__LINE__, ##__VA_ARGS__)
#define P2P_FRAME_WARN(fmt, ...)     LOG_E("P2P_FRAME[%s:%d]"fmt, __func__,__LINE__, ##__VA_ARGS__)

#define wf_memmove memmove
#define WF_GET_LE16(a) ((wf_u16) (((a)[1] << 8) | (a)[0]))
#define WF_PUT_LE16(a, val) \
    do {    \
        (a)[1] = ((wf_u16) (val)) >> 8;\
        (a)[0] = ((wf_u16) (val)) & 0xff;\
    } while (0)

#define WF_PUT_BE16(a, val)         \
        do {                    \
            (a)[0] = ((wf_u16) (val)) >> 8;    \
            (a)[1] = ((wf_u16) (val)) & 0xff;  \
        } while (0)

#define WF_GET_BE32(a) ((((wf_u32) (a)[0]) << 24) | (((wf_u32) (a)[1]) << 16) | \
                         (((wf_u32) (a)[2]) << 8) | ((wf_u32) (a)[3]))
#define WF_PUT_BE32(a, val)                 \
                do {                            \
                    (a)[0] = (wf_u8) ((((wf_u32) (val)) >> 24) & 0xff);   \
                    (a)[1] = (wf_u8) ((((wf_u32) (val)) >> 16) & 0xff);   \
                    (a)[2] = (wf_u8) ((((wf_u32) (val)) >> 8) & 0xff);    \
                    (a)[3] = (wf_u8) (((wf_u32) (val)) & 0xff);       \
                } while (0)

#define WLAN_EID_VENDOR_SPECIFIC 221

wf_u8 *p2p_ie_to_get_func(wf_u8 * in_ie, wf_s32 in_len, wf_u8 * p2p_ie, wf_u32 * p2p_ielen)
{
    wf_u32 cnt;
    wf_u8 *p2p_ie_ptr = NULL;
    wf_u8 eid;

    if (p2p_ielen)
    {
        *p2p_ielen = 0;
    }

    if (!in_ie || in_len < 0)
    {
        LOG_W("[%s,%d] in_len is not right",__func__,__LINE__);
        return p2p_ie_ptr;
    }

    if (in_len <= 0)
    {
        return p2p_ie_ptr;
    }

    cnt = 0;

    while (cnt + 1 + 4 < in_len)
    {
        eid = in_ie[cnt];

        if (cnt + 1 + 4 >= WF_80211_IES_SIZE_MAX)
        {
            LOG_W("[%s,%d] cnt is not right",__func__,__LINE__);
            return NULL;
        }

        if (eid == WF_80211_MGMT_EID_VENDOR_SPECIFIC && wf_memcmp(&in_ie[cnt + 2], P2P_OUI, 4) == 0)
        {
            p2p_ie_ptr = in_ie + cnt;

            if (p2p_ie)
            {
                wf_memcpy(p2p_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);
            }

            if (p2p_ielen)
            {
                *p2p_ielen = in_ie[cnt + 1] + 2;
            }

            break;
        }
        else
        {
            cnt += in_ie[cnt + 1] + 2;
        }

    }

    return p2p_ie_ptr;
}

void p2p_ie_dump_func(void *sel, wf_u8 * ie, wf_u32 ie_len, wf_u8 flag)
{
    wf_u8 *pos = (wf_u8 *) ie;
    wf_u8 id;
    wf_u16 len;

    wf_u8 *p2p_ie;
    wf_u32 p2p_ielen;

    p2p_ie = p2p_ie_to_get_func(ie, ie_len, NULL, &p2p_ielen);
    if (p2p_ie != ie || p2p_ielen == 0)
    {
        return;
    }

    if (flag)
    {
        pos += 6;
    }
    while (pos - ie + 3 <= ie_len)
    {
        id = *pos;
        len = WF_GET_LE16(pos + 1);

        LOG_I("%s ID:%u, LEN:%u%s\n", __func__, id, len,((pos - ie + 3 + len) <= ie_len) ? "" : "(exceed ie_len)");

        pos += (3 + len);
    }
}

static wf_u8 *p2p_attr_to_get_func(wf_u8 * p2p_ie, wf_u32 p2p_ielen, wf_u8 target_attr_id,wf_u8 * buf_attr, wf_u32 * len_attr)
{
    wf_u8 *attr_ptr = NULL;
    wf_u8 *target_attr_ptr = NULL;
    if (len_attr)
        *len_attr = 0;

    if (!p2p_ie || p2p_ielen <= 6 || (p2p_ie[0] != WLAN_EID_VENDOR_SPECIFIC) || (wf_memcmp(p2p_ie + 2, P2P_OUI, 4) != 0))
    {
        return attr_ptr;
    }

    attr_ptr = p2p_ie + 6;

    while ((attr_ptr - p2p_ie + 3) <= p2p_ielen)
    {
        wf_u8 attr_id = *attr_ptr;
        wf_u16 attr_data_len = WF_GET_LE16(attr_ptr + 1);
        wf_u16 attr_len = attr_data_len + 3;

        if (0)
        {
            LOG_I("%s attr_ptr:%p, id:%u, length:%u\n", __func__, attr_ptr, attr_id, attr_data_len);
        }

        if ((attr_ptr - p2p_ie + attr_len) > p2p_ielen)
        {
            break;
        }

        if (attr_id == target_attr_id)
        {
            target_attr_ptr = attr_ptr;

            if (buf_attr)
            {
                wf_memcpy(buf_attr, attr_ptr, attr_len);
            }

            if (len_attr)
            {
                *len_attr = attr_len;
            }

            break;
        } else {
            attr_ptr += attr_len;
        }
    }

    return target_attr_ptr;
}

wf_u8 *p2p_attr_content_to_get_func(wf_u8 * p2p_ie, wf_u32 p2p_ielen, wf_u8 target_attr_id, wf_u8 * buf_content, wf_u32 * len_content)
{
    wf_u8 *attr_ptr;
    wf_u32 attr_len;

    if (len_content)
    {
        *len_content = 0;
    }

    attr_ptr = p2p_attr_to_get_func(p2p_ie, p2p_ielen, target_attr_id, NULL, &attr_len);

    if (attr_ptr && attr_len)
    {
        if (buf_content)
        {
            wf_memcpy(buf_content, attr_ptr + 3, attr_len - 3);
        }

        if (len_content)
        {
            *len_content = attr_len - 3;
        }

        return attr_ptr + 3;
    }

    return NULL;
}

wf_u32 p2p_set_ie(wf_u8 * pbuf, wf_u8 index, wf_u16 attr_len, wf_u8 * pdata_attr)
{
    wf_u32 a_len = 0;
    *pbuf = index;

    WF_PUT_LE16(pbuf + 1, attr_len);

    if (pdata_attr)
    {
        wf_memcpy(pbuf + 3, pdata_attr, attr_len);
    }

    a_len = attr_len + 3;

    return a_len;
}
/*
static wf_u32 p2p_ie_to_del_func(wf_u8 * ies, wf_u32 ies_len_ori, const wf_u8 *msg, wf_u8 flag)
{
    wf_u8 *target_ie;
    wf_u32 target_ie_len;
    wf_u32 ies_len = ies_len_ori;
    wf_s32 index = 0;

    if (flag) {
        while (1) {
            target_ie = p2p_ie_to_get_func(ies, ies_len, NULL, &target_ie_len);
            if (target_ie && target_ie_len) {
                wf_u8 *next_ie = target_ie + target_ie_len;
                wf_u32 remain_len = ies_len - (next_ie - ies);
                wf_memmove(target_ie, next_ie, remain_len);
                wf_memset(target_ie + remain_len, 0, target_ie_len);
                ies_len -= target_ie_len;

                index++;
            } else {
                break;
            }
        }
    }
    return ies_len;
}


static wf_u32 p2p_attr_to_del_func(wf_u8 * ie, wf_u32 ielen_ori, wf_u8 attr_id, wf_u8 flag)
{
    wf_u8 *target_attr;
    wf_u32 target_attr_len;
    wf_u32 ielen = ielen_ori;
    wf_s32 index = 0;

    if (flag) {
        while (1) {
            target_attr =
                p2p_attr_to_get_func(ie, ielen, attr_id, NULL, &target_attr_len);
            if (target_attr && target_attr_len) {
                wf_u8 *next_attr = target_attr + target_attr_len;
                wf_u32 remain_len = ielen - (next_attr - ie);
                wf_memmove(target_attr, next_attr, remain_len);
                wf_memset(target_attr + remain_len, 0, target_attr_len);
                *(ie + 1) -= target_attr_len;
                ielen -= target_attr_len;

                index++;
            } else {
                break;
            }
        }
    }
    return ielen;
}

wf_u32 beacon_p2p_ie_build_func(p2p_wd_info_st *pwdinfo, wf_u8 * pbuf, wf_u8 vendor_flag)
{
    wf_u8 p2pie[WF_MAX_P2P_IE_LEN]  = { 0x00 };
    wf_u16 capability               = 0;
    wf_u32 len                      = 0;
    wf_u32 p2pielen                 = 0;

    p2pie[p2pielen++]   = 0x50;
    p2pie[p2pielen++]   = 0x6F;
    p2pie[p2pielen++]   = 0x9A;
    p2pie[p2pielen++]   = 0x09;
    capability          = P2P_DEVCAP_INVITATION_PROC | P2P_DEVCAP_CLIENT_DISCOVERABILITY;
    capability          |= ((P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS) << 8);

    if (pwdinfo->p2p_state == P2P_STATE_PROVISIONING_ING)
    {
        capability |= (P2P_GRPCAP_GROUP_FORMATION << 8);
    }

    capability          = wf_cpu_to_le16(capability);

    p2pielen            += p2p_set_ie(&p2pie[p2pielen], P2P_ATTR_CAPABILITY, 2, (wf_u8 *) & capability);

    p2pielen            += p2p_set_ie(&p2pie[p2pielen], P2P_ATTR_DEVICE_ID, WF_WF_ETH_ALEN, pwdinfo->device_addr);

    if (vendor_flag)
    {
        pbuf            = set_ie(pbuf, WF_80211_MGMT_EID_VENDOR_SPECIFIC, p2pielen, (unsigned char *)p2pie, &len);
    }

    return len;

}
*/
static wf_u8 *ie_ex_to_get_func(wf_u8 * in_ie, wf_u32 in_len, wf_u8 eid, wf_u8 * oui, wf_u8 oui_len,
                  wf_u8 * ie, wf_u32 * ielen, wf_u8 flag)
{
    wf_u32 cnt;
    wf_u8 *target_ie = NULL;

    if (flag) {
        if (ielen)
            *ielen = 0;
    }
    if (!in_ie || in_len <= 0)
        return target_ie;

    cnt = 0;

    while (cnt < in_len) {
        if (eid == in_ie[cnt]
            && (!oui || wf_memcmp(&in_ie[cnt + 2], oui, oui_len) == wf_true)) {
            target_ie = &in_ie[cnt];

            if (ie)
                wf_memcpy(ie, &in_ie[cnt], in_ie[cnt + 1] + 2);

            if (ielen)
                *ielen = in_ie[cnt + 1] + 2;

            break;
        } else {
            cnt += in_ie[cnt + 1] + 2;
        }

    }

    return target_ie;
}


int wf_remove_ie(wf_u8 * ies, wf_u32 * ies_len, wf_u32 offset, wf_u8 eid, wf_u8 * oui, wf_u8 oui_len, wf_u8 flag)
{
    int ret = -1;
    wf_u8 *target_ie;
    wf_u32 target_ielen;
    wf_u8 *start;
    wf_u32 search_len;

    if (flag) {
        if (!ies || !ies_len || *ies_len <= offset)
            goto exit;
    }
    start = ies + offset;
    search_len = *ies_len - offset;

    while (1) {
        target_ie =
            ie_ex_to_get_func(start, search_len, eid, oui, oui_len, NULL,
                          &target_ielen, 1);
        if (target_ie && target_ielen) {
            wf_u8 *remain_ies = target_ie + target_ielen;
            wf_u32 remain_len = search_len - (remain_ies - start);

            wf_memmove(target_ie, remain_ies, remain_len);
            *ies_len = *ies_len - target_ielen;
            ret = 0;

            start = target_ie;
            search_len = remain_len;
        } else {
            break;
        }
    }
exit:
    return ret;
}


wf_s32 p2p_assoc_rsp_frame_fill(nic_info_st *pnic_info, wf_u8 *pframe, wf_u16 *pkt_len,WF_P2P_IE_E pie_type)
{
    p2p_info_st *p2p_info = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;

    if(WF_P2P_IE_MAX <= pie_type)
    {
        P2P_FRAME_WARN("unknown ie_type:%d",pie_type);
        return -1;
    }
    if (p2p_info->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211
        && pwdinfo->role == P2P_ROLE_GO) 
    {
        if (p2p_info->p2p_ie[WF_P2P_IE_ASSOC_RSP] && p2p_info->p2p_ie_len[WF_P2P_IE_ASSOC_RSP] > 0)
        {
            P2P_FRAME_DBG("[%d] %s:%d",pnic_info->ndev_id,wf_p2p_ie_to_str(WF_P2P_IE_ASSOC_RSP),p2p_info->p2p_ie_len[WF_P2P_IE_ASSOC_RSP]);
            wf_memcpy((void *)pframe, (void *)p2p_info->p2p_ie[WF_P2P_IE_ASSOC_RSP],p2p_info->p2p_ie_len[WF_P2P_IE_ASSOC_RSP]);
            *pkt_len += p2p_info->p2p_ie_len[WF_P2P_IE_ASSOC_RSP];
            
        }
        else if (p2p_info->p2p_ie[pie_type] && p2p_info->p2p_ie_len[pie_type] > 0) 
        {
            P2P_FRAME_DBG("[%d] %s:%d",pnic_info->ndev_id,wf_p2p_ie_to_str(pie_type),p2p_info->p2p_ie_len[pie_type]);
            wf_memcpy((void *)pframe, (void *)p2p_info->p2p_ie[pie_type],p2p_info->p2p_ie_len[pie_type]);
            *pkt_len += p2p_info->p2p_ie_len[pie_type];
        }
    } 

    return 0;
}

wf_u8 * wf_p2p_frame_assoc_req_fill(nic_info_st *pnic_info, wf_u8 *pframe, wf_u32 *pkt_len,WF_P2P_IE_E pie_type)
{

    p2p_info_st *p2p_info           = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;

    P2P_FRAME_DBG("[%d] start",pnic_info->ndev_id);
    if(WF_P2P_IE_MAX <= pie_type)
    {
        P2P_FRAME_WARN("unknown ie_type:%d",pie_type);
        return NULL;
    }
#ifdef CONFIG_IOCTL_CFG80211
    if (p2p_info->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211) 
    {
        if (p2p_info->p2p_ie[pie_type] && p2p_info->p2p_ie_len[pie_type] > 0) 
        {
            P2P_FRAME_DBG("[%d] %s:%d",pnic_info->ndev_id,wf_p2p_ie_to_str(pie_type),p2p_info->p2p_ie_len[pie_type]);
            wf_memcpy((void *)pframe, (void *)p2p_info->p2p_ie[pie_type],p2p_info->p2p_ie_len[pie_type]);
            pframe += p2p_info->p2p_ie_len[pie_type];
            *pkt_len += p2p_info->p2p_ie_len[pie_type];
        }
    } else
#endif
    {
        if (pwdinfo->p2p_state != P2P_STATE_NONE && pwdinfo->p2p_state != P2P_STATE_IDLE) 
        {
            wf_u8 p2pie[255] = { 0x00 };
            wf_u16 p2pielen = 0;

            p2pie[p2pielen++] = 0x50;
            p2pie[p2pielen++] = 0x6F;
            p2pie[p2pielen++] = 0x9A;
            p2pie[p2pielen++] = 0x09;

            p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;

            *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0002);
            p2pielen += 2;

            p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;

            if (pwdinfo->persistent_supported)
                p2pie[p2pielen++] =
                    P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
            else
                p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;

            p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;

            *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0004);
            p2pielen += 2;

            *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0xFFFF);
            p2pielen += 2;

            *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0xFFFF);
            p2pielen += 2;

            p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;

            *(wf_u16 *) (p2pie + p2pielen) =
                wf_cpu_to_le16(21 + pwdinfo->device_name_len);
            p2pielen += 2;

            wf_memcpy(p2pie + p2pielen, nic_to_local_addr(pnic_info), WF_ETH_ALEN);
            p2pielen += WF_ETH_ALEN;

            if ((pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN)
                || (pwdinfo->ui_got_wps_info ==
                    P2P_GOT_WPSINFO_SELF_DISPLAY_PIN)) 
            {
                *(wf_u16 *) (p2pie + p2pielen) =
                    wf_cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
            } else {
                *(wf_u16 *) (p2pie + p2pielen) =
                    wf_cpu_to_be16(WPS_CONFIG_METHOD_PBC);
            }

            p2pielen += 2;

            *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
            p2pielen += 2;

            *(wf_u32 *) (p2pie + p2pielen) = wf_cpu_to_be32(WPSOUI);
            p2pielen += 4;

            *(wf_u16 *) (p2pie + p2pielen) =
                wf_cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
            p2pielen += 2;

            p2pie[p2pielen++] = 0x00;

            *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(WPS_ATTR_DEVICE_NAME);
            p2pielen += 2;

            *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(pwdinfo->device_name_len);
            p2pielen += 2;

            wf_memcpy(p2pie + p2pielen, pwdinfo->device_name,pwdinfo->device_name_len);
            p2pielen += pwdinfo->device_name_len;

            p2pie[p2pielen++] = P2P_ATTR_INTERFACE;

            *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x000D);
            p2pielen += 2;

            wf_memcpy(p2pie + p2pielen, pwdinfo->device_addr, WF_ETH_ALEN);
            p2pielen += WF_ETH_ALEN;

            p2pie[p2pielen++] = 1;

            wf_memcpy(p2pie + p2pielen, pwdinfo->device_addr, WF_ETH_ALEN);
            p2pielen += WF_ETH_ALEN;

            pframe =set_ie(pframe, WF_80211_MGMT_EID_VENDOR_SPECIFIC, p2pielen,(unsigned char *)p2pie, pkt_len);
        }
    }


#ifdef CONFIG_WFD
//  wfdielen = assoc_req_wfd_ie_to_append_func(pwadptdata, pframe, 1);
//  pframe += wfdielen;
//  pattrib->pktlen += wfdielen;
#endif

    return pframe;
}

wf_u32 p2p_attr_content_to_set_func(wf_u8 * pbuf, wf_u8 attr_id, wf_u16 attr_len,wf_u8 * pdata_attr, wf_u8 flag)
{
    wf_u32 a_len;

    *pbuf = attr_id;

    WF_PUT_LE16(pbuf + 1, attr_len);

    if (flag && pdata_attr) 
    {
        wf_memcpy(pbuf + 3, pdata_attr, attr_len);
    }
    a_len = attr_len + 3;

    return a_len;
}

static wf_s32 add_group_info_attr_of_go_func(nic_info_st *pnic_info, wf_u8 * pbuf, wf_u8 flag)
{
    wf_u32 len = 0;
    wf_u16 attr_len = 0;
    wf_u8 tmplen, *pdata_attr, *pstart, *pcur;
    wdn_net_info_st *pwdn = NULL;
    wf_s32 i = 0;
    p2p_info_st *p2p_info  = pnic_info->p2p;
    P2P_FRAME_DBG("[%d] %s\n", pnic_info->ndev_id,__FUNCTION__);

    pdata_attr = wf_kzalloc(WF_MAX_P2P_IE_LEN);

    if (NULL == pdata_attr) 
    {
        P2P_FRAME_DBG("[%d] %s pdata_attr malloc failed \n", pnic_info->ndev_id,__FUNCTION__);
        return -1;
    }

    pstart = pdata_attr;
    pcur = pdata_attr;

    if(wf_true == p2p_info->p2p_enabled)
    for (i = 0; i < WDN_NUM_MAX; i++)
    {
        pwdn = wf_wdn_find_info_by_id(pnic_info, i);
        if(pwdn && 0 != wf_memcmp(nic_to_local_addr(pnic_info),pwdn->mac,WF_ETH_ALEN))
        {
            wf_memcpy(pcur, nic_to_local_addr(pnic_info), WF_ETH_ALEN);
            pcur += WF_ETH_ALEN;
            
            wf_memcpy(pcur, pwdn->mac, WF_ETH_ALEN);
            pcur += WF_ETH_ALEN;

            *pcur = pwdn->dev_cap;
            pcur++;

            WF_PUT_BE16(pcur, pwdn->config_methods);
            pcur += 2;

            wf_memcpy(pcur, pwdn->primary_dev_type, 8);
            pcur += 8;

            *pcur = pwdn->num_of_secdev_type;
            pcur++;

            wf_memcpy(pcur, pwdn->secdev_types_list,
                        pwdn->num_of_secdev_type * 8);
            pcur += pwdn->num_of_secdev_type * 8;

            if (pwdn->dev_name_len > 0) 
            {
                WF_PUT_BE16(pcur, WPS_ATTR_DEVICE_NAME);
                pcur += 2;

                WF_PUT_BE16(pcur, pwdn->dev_name_len);
                pcur += 2;

                wf_memcpy(pcur, pwdn->dev_name, pwdn->dev_name_len);
                pcur += pwdn->dev_name_len;
            }

            tmplen = (wf_u8) (pcur - pstart);

            *pstart = (tmplen - 1);

            attr_len += tmplen;

            pstart = pcur;
        }
    }

    if (attr_len > 0) 
    {
        len = p2p_attr_content_to_set_func(pbuf, P2P_ATTR_GROUP_INFO, attr_len,
                                     pdata_attr, 1);
    }

    if (flag) 
    {
        wf_kfree(pdata_attr);
    }

    return len;

}

wf_u32 probe_resp_p2p_ie_build_func(nic_info_st *pnic_info, wf_u8 * pbuf,wf_u8 flag)
{
    wf_u8 p2pie[WF_MAX_P2P_IE_LEN]  = { 0x00 };
    wf_u32 len                      = 0;
    wf_u32 p2pielen                 = 0;
    p2p_info_st *p2p_info           = pnic_info->p2p;
    p2p_wd_info_st * pwdinfo = &p2p_info->wdinfo;
    
    p2pielen = 0;
    p2pie[p2pielen++] = 0x50;
    p2pie[p2pielen++] = 0x6F;
    p2pie[p2pielen++] = 0x9A;
    p2pie[p2pielen++] = 0x09;

    p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;

    WF_PUT_LE16(p2pie + p2pielen, 0x0002);
    p2pielen += 2;

    p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;

    if (pwdinfo->role == P2P_ROLE_GO) 
    {
        p2pie[p2pielen] = (P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS);

        if (pwdinfo->p2p_state == P2P_STATE_PROVISIONING_ING)
            p2pie[p2pielen] |= P2P_GRPCAP_GROUP_FORMATION;

        p2pielen++;
    } else if (pwdinfo->role ==P2P_ROLE_DEVICE) {
        if (pwdinfo->persistent_supported)
            p2pie[p2pielen++] =
                P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
        else
            p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
    }

    p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;

    WF_PUT_LE16(p2pie + p2pielen, 0x0004);
    p2pielen += 2;

    WF_PUT_LE16(p2pie + p2pielen, 0xFFFF);
    p2pielen += 2;

    WF_PUT_LE16(p2pie + p2pielen, 0xFFFF);
    p2pielen += 2;

    p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;

    WF_PUT_LE16(p2pie + p2pielen, 21 + pwdinfo->device_name_len);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, pwdinfo->device_addr, WF_ETH_ALEN);
    p2pielen += WF_ETH_ALEN;

    WF_PUT_BE16(p2pie + p2pielen, pwdinfo->supported_wps_cm);
    p2pielen += 2;

    WF_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_MULIT_MEDIA);
    p2pielen += 2;

    WF_PUT_BE32(p2pie + p2pielen, WPSOUI);
    p2pielen += 4;

    WF_PUT_BE16(p2pie + p2pielen, WPS_PDT_SCID_MEDIA_SERVER);
    p2pielen += 2;

    p2pie[p2pielen++] = 0x00;

    WF_PUT_BE16(p2pie + p2pielen, WPS_ATTR_DEVICE_NAME);
    p2pielen += 2;

    WF_PUT_BE16(p2pie + p2pielen, pwdinfo->device_name_len);
    p2pielen += 2;

    if (flag)
    {
        wf_memcpy(p2pie + p2pielen, pwdinfo->device_name,
                    pwdinfo->device_name_len);
        p2pielen += pwdinfo->device_name_len;
    }
    if (pwdinfo->role == P2P_ROLE_GO)
    {
        p2pielen += add_group_info_attr_of_go_func(pnic_info, p2pie + p2pielen, 1);
    }

    pbuf = set_ie(pbuf, WF_80211_MGMT_EID_VENDOR_SPECIFIC, p2pielen, (unsigned char *)p2pie, &len);

    return len;

}


wf_s32 p2p_provision_request_to_issue_func(nic_info_st *pnic_info, wf_u8 * pssid, wf_u8 ussidlen,wf_u8 * pdev_raddr, wf_u8 flag)
{
#if 0
    unsigned char category = WL_WLAN_CATEGORY_PUBLIC;
    u8 action = P2P_PUB_ACTION_ACTION;
    u8 dialogToken = 1;
    u32 p2poui = cpu_to_be32(P2POUI);
    u8 oui_subtype = P2P_PROVISION_DISC_REQ;
    u8 wpsie[100] = { 0x00 };
    u8 wpsielen = 0;
    u32 p2pielen = 0;
#ifdef CONFIG_WFD
    u32 wfdielen = 0;
#endif

    struct xmit_frame *pmgntframe;
    struct pkt_attrib *pattrib;
    unsigned char *pframe;
    struct wl_ieee80211_hdr *pwlanhdr;
    unsigned short *fctrl;
    struct xmit_priv *pxmitpriv = &(pwadptdata->xmitpriv);
    struct mlme_ext_priv *pmlmeext = &(pwadptdata->mlmeextpriv);
    struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
    p2p_wd_info_st *pwdinfo = &(pwadptdata->wdinfo);

    if ((pmgntframe = proc_alloc_mgtxmitframe_func(pxmitpriv)) == NULL) {
        return;
    }

    P2P_FRAME_INFO("[%s] In\n", __FUNCTION__);
    pattrib = &pmgntframe->attrib;
    proc_mgntframe_attrib_update_func(pwadptdata, pattrib);

    if (flag) {
        memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
    }
    pframe = (u8 *) (pmgntframe->buf_addr) + TXDESC_OFFSET;
    pwlanhdr = (struct wl_ieee80211_hdr *)pframe;

    fctrl = &(pwlanhdr->frame_ctl);
    *(fctrl) = 0;

    wf_memcpy(pwlanhdr->addr1, pdev_raddr, ETH_ALEN);
    wf_memcpy(pwlanhdr->addr2, wadptdata_mac_addr(pwadptdata), ETH_ALEN);
    wf_memcpy(pwlanhdr->addr3, pdev_raddr, ETH_ALEN);

    SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
    pmlmeext->mgnt_seq++;
    SetFrameSubType(pframe, WIFI_ACTION);

    pframe += sizeof(struct wl_ieee80211_hdr_3addr);
    pattrib->pktlen = sizeof(struct wl_ieee80211_hdr_3addr);

    pframe = fixed_ie_to_set_func(1, pframe, 1, &(category), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(action), &(pattrib->pktlen));
    pframe =
        fixed_ie_to_set_func(1, pframe, 4, (unsigned char *)&(p2poui),
                         &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(oui_subtype), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(dialogToken), &(pattrib->pktlen));

    p2pielen =
        prov_disc_request_p2p_ie_build_func(pwdinfo, pframe, pssid, ussidlen,
                                       pdev_raddr, 1);

    pframe += p2pielen;
    pattrib->pktlen += p2pielen;

    wpsielen = 0;
    *(u32 *) (wpsie) = cpu_to_be32(WPSOUI);
    wpsielen += 4;

    *(u16 *) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
    wpsielen += 2;

    *(u16 *) (wpsie + wpsielen) = cpu_to_be16(0x0001);
    wpsielen += 2;

    wpsie[wpsielen++] = WPS_VERSION_1;

    *(u16 *) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
    wpsielen += 2;

    *(u16 *) (wpsie + wpsielen) = cpu_to_be16(0x0002);
    wpsielen += 2;

    *(u16 *) (wpsie + wpsielen) =
        cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
    wpsielen += 2;

    pframe =
        ie_to_set_func(pframe, _VENDOR_SPECIFIC_IE_, wpsielen,
                   (unsigned char *)wpsie, &pattrib->pktlen);

#ifdef CONFIG_WFD
    wfdielen = provdisc_req_wfd_ie_build_func(pwdinfo, pframe, 1);
    pframe += wfdielen;
    pattrib->pktlen += wfdielen;
#endif

    pattrib->last_txcmdsz = pattrib->pktlen;

    mgntframe_to_dump_func(pwadptdata, pmgntframe);

    return;
#else
    P2P_FRAME_WARN("need to do");
#endif
    return 0;
}

wf_s32 p2p_GO_request_to_issue_func(nic_info_st *pnic_info, wf_u8 *raddr, wf_u8 flag)
{
#if 0
    wf_u8 category      = WF_WLAN_CATEGORY_PUBLIC;
    wf_u8 action        = P2P_PUB_ACTION_ACTION;
    wf_u32 p2poui       = wf_cpu_to_be32(P2POUI);
    wf_u8 oui_subtype   = P2P_GO_NEGO_REQ;
    wf_u8 wpsie[255]    = { 0x00 }, p2pie[255] = {0x00};
    wf_u8 wpsielen      = 0, p2pielen = 0, i;
    wf_u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
    wf_u16 len_channellist_attr = 0;
#ifdef CONFIG_WFD
    wf_u32 wfdielen = 0;
#endif

    tx_info_st *ptx_info        = (tx_info_st *)pnic_info->tx_info;
    struct xmit_buf *pxmit_buf  = NULL;
    wf_80211_mgmt_t *pframe     = NULL;
    wf_u32 var_len              = 0;
    wf_u8 *pvar                 = NULL;
    p2p_info_st *p2p_info       = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;

    /* alloc xmit_buf */
    pxmit_buf = wf_xmit_extbuf_new(ptx_info);
    if (pxmit_buf == NULL)
    {
        LOG_W("[%s] pxmit_buf is NULL",__func__);
        return -1;
    }

    /* set frame head */
    wf_memset(pxmit_buf->pbuf, 0,TXDESC_OFFSET + WF_OFFSETOF(wf_80211_mgmt_t, probe_req));
    pframe = (void *)&pxmit_buf->pbuf[TXDESC_OFFSET];
    

    /* set control field */
    wf_80211_set_frame_type(&pframe->frame_control, WF_80211_STYPE_ACTION);

    /* set address field */
    wf_memcpy(pframe->da, raddr, WF_ETH_ALEN);
    wf_memcpy(pframe->sa, nic_to_local_addr(pnic_info), WF_ETH_ALEN);
    wf_memcpy(pframe->bssid, nic_to_local_addr(pnic_info), WF_ETH_ALEN);

    pframe += sizeof(struct wl_ieee80211_hdr_3addr);
    var_len = 0;
    
    pframe = set_fixed_ie( pframe, 1, &(category), &var_len);
    pframe = set_fixed_ie( pframe, 1, &(action), &var_len);
    pframe =
        set_fixed_ie( pframe, 4, (unsigned char *)&(p2poui),
                         &var_len);
    pframe = set_fixed_ie( pframe, 1, &(oui_subtype), &var_len);
    pwdinfo->negotiation_dialog_token = 1;
    pframe =
        set_fixed_ie( pframe, 1, &pwdinfo->negotiation_dialog_token,
                         &var_len);

    wpsielen = 0;
    *(wf_u32 *) (wpsie) = wf_cpu_to_be32(WPSOUI);
    wpsielen += 4;

    *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_VER1);
    wpsielen += 2;

    *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
    wpsielen += 2;

    wpsie[wpsielen++] = WPS_VERSION_1;

    *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_DEVICE_PWID);
    wpsielen += 2;

    *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0002);
    wpsielen += 2;

    if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN) 
    {
        *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_DPID_USER_SPEC);
    } 
    else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN) 
    {
        *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
    } 
    else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC) 
    {
        *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_DPID_PBC);
    }

    wpsielen += 2;

    pframe =set_ie(pframe, WLAN_EID_VENDOR_SPECIFIC, wpsielen,(unsigned char *)wpsie, &var_len);

    p2pielen = 0;
    p2pie[p2pielen++] = 0x50;
    p2pie[p2pielen++] = 0x6F;
    p2pie[p2pielen++] = 0x9A;
    p2pie[p2pielen++] = 0x09;

    p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0002);
    p2pielen += 2;

    p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;

    if (pwdinfo->persistent_supported) 
    {
        p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
    } 
    else 
    {
        p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
    }

    p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0001);
    p2pielen += 2;

    p2pie[p2pielen++] = ((pwdinfo->intent << 1) & 0xFE);

    p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0002);
    p2pielen += 2;

    p2pie[p2pielen++] = 200;
    p2pie[p2pielen++] = 200;

    p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0005);
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

    p2pie[p2pielen++] = 0x51;

    p2pie[p2pielen++] = pwdinfo->listen_channel;

    p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0004);
    p2pielen += 2;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0xFFFF);
    p2pielen += 2;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0xFFFF);
    p2pielen += 2;

    p2pie[p2pielen++] = P2P_ATTR_INTENTED_IF_ADDR;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(WF_ETH_ALEN);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, nic_to_local_addr(nic_info), WF_ETH_ALEN);
    p2pielen += WF_ETH_ALEN;

    p2pie[p2pielen++] = P2P_ATTR_CH_LIST;

    len_channellist_attr = 3 + (1 + 1) * (wf_u16) (p2p_info->channel_list.reg_classes) + reg_classes_full_count_to_get_func(p2p_info->channel_list);

#ifdef CONFIG_CONCURRENT_MODE
    if (wf_p2p_check_buddy_linkstate(nic_info)
        && nic_info->registrypriv.full_ch_in_p2p_handshake == 0) {
        *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(5 + 1);
    } else {
        *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(len_channellist_attr);
    }
#else

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(len_channellist_attr);

#endif
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

#ifdef CONFIG_CONCURRENT_MODE
    if (wf_p2p_check_buddy_linkstate(nic_info)
        && p2p_info->full_ch_in_p2p_handshake == 0) 
    {
        _wadptdata *pbuddy_wadptdata = nic_info->pbuddy_wadptdata;
        struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_wadptdata->mlmeextpriv;

        if (pbuddy_mlmeext->cur_channel <= 14) {
            p2pie[p2pielen++] = 0x51;
        }

        p2pie[p2pielen++] = 1;

        p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
    } else 
    {
        wf_s32 i, j;
        for (j = 0; j < p2p_info->channel_list.reg_classes; j++) {
            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].reg_class;

            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].channels;

            for (i = 0; i < p2p_info->channel_list.reg_class[j].channels; i++) {
                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].channel[i];
            }
        }
    }
#else
    {
        wf_s32 i, j;
        for (j = 0; j < p2p_info->channel_list.reg_classes; j++) 
        {
            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].reg_class;

            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].channels;

            for (i = 0; i < p2p_info->channel_list.reg_class[j].channels; i++) 
            {
                p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].channel[i];
            }
        }
    }
#endif

    p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(21 + pwdinfo->device_name_len);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, nic_to_local_addr(nic_info), WF_ETH_ALEN);
    p2pielen += WF_ETH_ALEN;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(pwdinfo->supported_wps_cm);

    p2pielen += 2;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
    p2pielen += 2;

    *(wf_u32 *) (p2pie + p2pielen) = wf_cpu_to_be32(WPSOUI);
    p2pielen += 4;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
    p2pielen += 2;

    p2pie[p2pielen++] = 0x00;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(WPS_ATTR_DEVICE_NAME);
    p2pielen += 2;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(pwdinfo->device_name_len);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, pwdinfo->device_name,pwdinfo->device_name_len);
    p2pielen += pwdinfo->device_name_len;

    p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0005);
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

    if (pwdinfo->operating_channel <= 14) 
    {
        p2pie[p2pielen++] = 0x51;
    }

    p2pie[p2pielen++] = pwdinfo->operating_channel;

    pframe =set_ie(pframe, WLAN_EID_VENDOR_SPECIFIC, p2pielen,
                   (unsigned char *)p2pie, &var_len);

#ifdef CONFIG_WFD
//    wfdielen = nego_req_wfd_ie_build_func(pwdinfo, pframe, 1);
//    pframe += wfdielen;
//    var_len += wfdielen;
#endif

     /* frame send */
    pxmit_buf->pkt_len = WF_OFFSETOF(wf_80211_mgmt_t, probe_req.variable) + var_len;
    if (wf_nic_mgmt_frame_xmit(pnic_info, NULL, pxmit_buf, pxmit_buf->pkt_len))
    {
        LOG_W("probe frame send fail");
        return -1;
    }

    return 0;
#else
    P2P_FRAME_WARN("need to do");
#endif
    return 0;
}

static void p2p_GO_response_to_issue_func(nic_info_st * pnic_info, u8 * raddr, u8 * frame_body,
                           uint len, u8 result, u8 flag)
{
    #if 0
    unsigned char category = WF_WLAN_CATEGORY_PUBLIC;
    wf_u8 action = P2P_PUB_ACTION_ACTION;
    wf_u32 p2poui = wf_cpu_to_be32(P2POUI);
    wf_u8 oui_subtype = P2P_GO_NEGO_RESP;
    wf_u8 wpsie[255] = { 0x00 }, p2pie[255] = {
    0x00};
    wf_u8 p2pielen = 0, i;
    uint wpsielen = 0;
    wf_u16 wps_devicepassword_id = 0x0000;
    uint wps_devicepassword_id_len = 0;
    wf_u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh;
    wf_u16 len_channellist_attr = 0;
#ifdef CONFIG_WFD
    wf_u32 wfdielen = 0;
#endif
    tx_info_st *ptx_info        = (tx_info_st *)pnic_info->tx_info;
    struct xmit_buf *pxmit_buf  = NULL;
    wf_80211_mgmt_t *pframe     = NULL;
    wf_u32 var_len              = 0;
    wf_u8 *pvar                 = NULL;
    p2p_info_st *p2p_info       = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;

    /* alloc xmit_buf */
    pxmit_buf = wf_xmit_extbuf_new(ptx_info);
    if (pxmit_buf == NULL)
    {
        LOG_W("[%s] pxmit_buf is NULL",__func__);
        return -1;
    }

    /* set frame head */
    wf_memset(pxmit_buf->pbuf, 0,TXDESC_OFFSET + WF_OFFSETOF(wf_80211_mgmt_t, probe_req));
    pframe = (void *)&pxmit_buf->pbuf[TXDESC_OFFSET];
    

    /* set control field */
    wf_80211_set_frame_type(&pframe->frame_control, WF_80211_STYPE_ACTION);


    /* set address field */
    wf_memset(pframe->da, raddr, WF_ETH_ALEN);
    wf_memcpy(pframe->sa, nic_to_local_addr(pnic_info), WF_ETH_ALEN);
    wf_memset(pframe->bssid, nic_to_local_addr(pnic_info), WF_ETH_ALEN);

    pframe += sizeof(struct wl_ieee80211_hdr_3addr);
    var_len = 0;


    pframe = set_fixed_ie( pframe, 1, &(category), &var_len);
    pframe = set_fixed_ie( pframe, 1, &(action), &var_len);
    pframe =
        set_fixed_ie( pframe, 4, (unsigned char *)&(p2poui),
                         &var_len);
    pframe = set_fixed_ie( pframe, 1, &(oui_subtype), &var_len);
    pwdinfo->negotiation_dialog_token = frame_body[7];
    pframe =
        set_fixed_ie( pframe, 1, &(pwdinfo->negotiation_dialog_token),
                         &var_len);

    wf_wlan_get_wps_ie(frame_body + WF_PUBLIC_ACTION_IE_OFFSET,len - WF_PUBLIC_ACTION_IE_OFFSET, wpsie, &wpsielen, 1);
    wf_wlan_get_wps_attr_content(1, wpsie, wpsielen, WPS_ATTR_DEVICE_PWID,(wf_u8 *) & wps_devicepassword_id,&wps_devicepassword_id_len);
    wps_devicepassword_id = wf_be16_to_cpu(wps_devicepassword_id);

    wf_memset(wpsie, 0x00, 255);
    wpsielen = 0;

    wpsielen = 0;
    *(wf_u32 *) (wpsie) = wf_cpu_to_be32(WPSOUI);
    wpsielen += 4;

    *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_VER1);
    wpsielen += 2;

    *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
    wpsielen += 2;

    wpsie[wpsielen++] = WPS_VERSION_1;

    *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_DEVICE_PWID);
    wpsielen += 2;

    *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0002);
    wpsielen += 2;

    if (wps_devicepassword_id == WPS_DPID_USER_SPEC) 
    {
        *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
    } 
    else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC) 
    {
        *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_DPID_USER_SPEC);
    } 
    else 
    {
        *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_DPID_PBC);
    }
    wpsielen += 2;

    if (0 == wf_memcmp(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req,"000", 3)) 
    {
        if (wps_devicepassword_id == WPS_DPID_USER_SPEC) 
        {
            wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
        } 
        else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC) 
        {
            wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3);
        } 
        else 
        {
            wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3);
        }
    }

    pframe =set_ie(pframe, WLAN_EID_VENDOR_SPECIFIC, wpsielen, (unsigned char *)wpsie, &var_len);

    p2pielen = 0;
    p2pie[p2pielen++] = 0x50;
    p2pie[p2pielen++] = 0x6F;
    p2pie[p2pielen++] = 0x9A;
    p2pie[p2pielen++] = 0x09;

    p2pie[p2pielen++] = P2P_ATTR_STATUS;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0001);
    p2pielen += 2;

    p2pie[p2pielen++] = result;

    p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0002);
    p2pielen += 2;

    if (pwdinfo->role == P2P_ROLE_CLIENT) 
    {
        p2pie[p2pielen++] = 0;
    } else {
        p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
    }

    if (pwdinfo->persistent_supported) {
        p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
    } else {
        p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
    }

    p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0001);
    p2pielen += 2;

    if (pwdinfo->peer_intent & 0x01) {
        p2pie[p2pielen++] = (pwdinfo->intent << 1);
    } else {
        p2pie[p2pielen++] = ((pwdinfo->intent << 1) | BIT(0));
    }

    p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0002);
    p2pielen += 2;

    p2pie[p2pielen++] = 200;
    p2pie[p2pielen++] = 200;

    p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0005);
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

    if (pwdinfo->operating_channel <= 14) {
        p2pie[p2pielen++] = 0x51;
    }

    p2pie[p2pielen++] = pwdinfo->operating_channel;

    p2pie[p2pielen++] = P2P_ATTR_INTENTED_IF_ADDR;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(WF_ETH_ALEN);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, nic_to_local_addr(nic_info), WF_ETH_ALEN);
    p2pielen += WF_ETH_ALEN;

    p2pie[p2pielen++] = P2P_ATTR_CH_LIST;

    len_channellist_attr = 3
        + (1 + 1) * (u16) p2p_info->channel_list.reg_classes
        + reg_classes_full_count_to_get_func(p2p_info->channel_list);

#ifdef CONFIG_CONCURRENT_MODE
    if (wf_p2p_check_buddy_linkstate(nic_info)
        && nic_info->registrypriv.full_ch_in_p2p_handshake == 0) {
        *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(5 + 1);
    } else {
        *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(len_channellist_attr);
    }
#else

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(len_channellist_attr);

#endif
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

#ifdef CONFIG_CONCURRENT_MODE
    if (wf_p2p_check_buddy_linkstate(nic_info)
        && nic_info->registrypriv.full_ch_in_p2p_handshake == 0) {
        _wadptdata *pbuddy_wadptdata = nic_info->pbuddy_wadptdata;
        struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_wadptdata->mlmeextpriv;

        if (pbuddy_mlmeext->cur_channel <= 14) {
            p2pie[p2pielen++] = 0x51;
        }

        p2pie[p2pielen++] = 1;

        p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
    } else {
        int i, j;
        for (j = 0; j < p2p_info->channel_list.reg_classes; j++) {
            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].reg_class;

            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].channels;

            for (i = 0; i < p2p_info->channel_list.reg_class[j].channels; i++) {
                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].channel[i];
            }
        }
    }
#else
    {
        int i, j;
        for (j = 0; j < p2p_info->channel_list.reg_classes; j++) {
            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].reg_class;

            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].channels;

            for (i = 0; i < p2p_info->channel_list.reg_class[j].channels; i++) {
                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].channel[i];
            }
        }
    }
#endif

    p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(21 + pwdinfo->device_name_len);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, nic_to_local_addr(nic_info), WF_ETH_ALEN);
    p2pielen += WF_ETH_ALEN;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(pwdinfo->supported_wps_cm);

    p2pielen += 2;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
    p2pielen += 2;

    *(wf_u32 *) (p2pie + p2pielen) = wf_cpu_to_be32(WPSOUI);
    p2pielen += 4;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
    p2pielen += 2;

    p2pie[p2pielen++] = 0x00;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(WPS_ATTR_DEVICE_NAME);
    p2pielen += 2;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_be16(pwdinfo->device_name_len);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, pwdinfo->device_name,
                pwdinfo->device_name_len);
    p2pielen += pwdinfo->device_name_len;

    if (pwdinfo->role == P2P_ROLE_GO) 
    {
        p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;

        *(wf_u16 *) (p2pie + p2pielen) =
            wf_cpu_to_le16(WF_ETH_ALEN + pwdinfo->nego_ssidlen);
        p2pielen += 2;

        wf_memcpy(p2pie + p2pielen, pwdinfo->device_addr, WF_ETH_ALEN);
        p2pielen += WF_ETH_ALEN;

        wf_memcpy(p2pie + p2pielen, pwdinfo->nego_ssid,
                    pwdinfo->nego_ssidlen);
        p2pielen += pwdinfo->nego_ssidlen;

    }

    pframe =
        set_ie(pframe, WLAN_EID_VENDOR_SPECIFIC, p2pielen,
                   (unsigned char *)p2pie, &var_len);

#ifdef CONFIG_WFD
    wfdielen = nego_resp_wfd_ie_build_func(pwdinfo, pframe, 1);
    pframe += wfdielen;
    var_len += wfdielen;
#endif

     /* frame send */
    pxmit_buf->pkt_len = WF_OFFSETOF(wf_80211_mgmt_t, probe_req.variable) + var_len;
    if (wf_nic_mgmt_frame_xmit(pnic_info, NULL, pxmit_buf, pxmit_buf->pkt_len))
    {
        LOG_W("probe frame send fail");
        return -1;
    }

    return;
    #else
    P2P_FRAME_WARN("need to do");
    #endif
}

static void p2p_GO_confirm_to_issue_func(nic_info_st * pnic_info, wf_u8 * raddr, wf_u8 result, wf_u8 flag)
{
    #if 0
    wf_u8 category = WF_WLAN_CATEGORY_PUBLIC;
    wf_u8 action = P2P_PUB_ACTION_ACTION;
    wf_u32 p2poui = wf_cpu_to_be32(P2POUI);
    wf_u8 oui_subtype = P2P_GO_NEGO_CONF;
    wf_u8 wpsie[255] = { 0x00 };
    wf_u8 p2pie[255] = {0x00};
    wf_u8 wpsielen = 0, p2pielen = 0;

#ifdef CONFIG_WFD
    u32 wfdielen = 0;
#endif

    tx_info_st *ptx_info        = (tx_info_st *)pnic_info->tx_info;
    struct xmit_buf *pxmit_buf  = NULL;
    wf_80211_mgmt_t *pframe     = NULL;
    wf_u32 var_len              = 0;
    wf_u8 *pvar                 = NULL;
    p2p_info_st *p2p_info       = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;

    /* alloc xmit_buf */
    pxmit_buf = wf_xmit_extbuf_new(ptx_info);
    if (pxmit_buf == NULL)
    {
        LOG_W("[%s] pxmit_buf is NULL",__func__);
        return -1;
    }

    /* set frame head */
    wf_memset(pxmit_buf->pbuf, 0,TXDESC_OFFSET + WF_OFFSETOF(wf_80211_mgmt_t, probe_req));
    pframe = (void *)&pxmit_buf->pbuf[TXDESC_OFFSET];
    

    /* set control field */
    wf_80211_set_frame_type(&pframe->frame_control, WF_80211_STYPE_ACTION);


    /* set address field */
    wf_memset(pframe->da, raddr, WF_ETH_ALEN);
    wf_memcpy(pframe->sa, nic_to_local_addr(pnic_info), WF_ETH_ALEN);
    wf_memset(pframe->bssid, nic_to_local_addr(pnic_info), WF_ETH_ALEN);

    pframe += sizeof(struct wl_ieee80211_hdr_3addr);
    var_len = 0;

    pframe = set_fixed_ie( pframe, 1, &(category), &var_len);
    pframe = set_fixed_ie( pframe, 1, &(action), &var_len);
    pframe =
        set_fixed_ie( pframe, 4, (unsigned char *)&(p2poui),
                         &var_len);
    pframe = set_fixed_ie( pframe, 1, &(oui_subtype), &var_len);
    pframe =
        set_fixed_ie( pframe, 1, &(pwdinfo->negotiation_dialog_token),
                         &var_len);

    p2pielen = 0;
    p2pie[p2pielen++] = 0x50;
    p2pie[p2pielen++] = 0x6F;
    p2pie[p2pielen++] = 0x9A;
    p2pie[p2pielen++] = 0x09;

    p2pie[p2pielen++] = P2P_ATTR_STATUS;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0001);
    p2pielen += 2;

    p2pie[p2pielen++] = result;

    p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0002);
    p2pielen += 2;

    p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;

    if (pwdinfo->persistent_supported) {
        p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
    } else {
        p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
    }

    p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;

    *(wf_u16 *) (p2pie + p2pielen) = wf_cpu_to_le16(0x0005);
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

    if (pwdinfo->role == P2P_ROLE_CLIENT) {
        if (pwdinfo->peer_operating_ch <= 14) {
            p2pie[p2pielen++] = 0x51;
        }

        p2pie[p2pielen++] = pwdinfo->peer_operating_ch;
    } else {
        if (pwdinfo->operating_channel <= 14) {
            p2pie[p2pielen++] = 0x51;
        }

        p2pie[p2pielen++] = pwdinfo->operating_channel;
    }

    p2pie[p2pielen++] = P2P_ATTR_CH_LIST;

    *(u16 *) (p2pie + p2pielen) = 6;
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

    if (pwdinfo->role == P2P_ROLE_CLIENT) {
        if (pwdinfo->peer_operating_ch <= 14) {
            p2pie[p2pielen++] = 0x51;
        }

        p2pie[p2pielen++] = 1;
        p2pie[p2pielen++] = pwdinfo->peer_operating_ch;
    } else {
        if (pwdinfo->operating_channel <= 14) {
            p2pie[p2pielen++] = 0x51;
        }

        p2pie[p2pielen++] = 1;
        p2pie[p2pielen++] = pwdinfo->operating_channel;
    }

    if (pwdinfo->role == P2P_ROLE_GO) {
        p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;

        *(u16 *) (p2pie + p2pielen) =
            wf_cpu_to_le16(WF_ETH_ALEN + pwdinfo->nego_ssidlen);
        p2pielen += 2;

        wf_memcpy(p2pie + p2pielen, pwdinfo->device_addr, WF_ETH_ALEN);
        p2pielen += WF_ETH_ALEN;

        wf_memcpy(p2pie + p2pielen, pwdinfo->nego_ssid,
                    pwdinfo->nego_ssidlen);
        p2pielen += pwdinfo->nego_ssidlen;
    }

    pframe =
        set_ie(pframe, WLAN_EID_VENDOR_SPECIFIC, p2pielen,
                   (unsigned char *)p2pie, &var_len);

#ifdef CONFIG_WFD
    wfdielen = nego_confirm_wfd_ie_build_func(pwdinfo, pframe, 1);
    pframe += wfdielen;
    var_len += wfdielen;
#endif

     /* frame send */
    pxmit_buf->pkt_len = WF_OFFSETOF(wf_80211_mgmt_t, probe_req.variable) + var_len;
    if (wf_nic_mgmt_frame_xmit(pnic_info, NULL, pxmit_buf, pxmit_buf->pkt_len))
    {
        LOG_W("probe frame send fail");
        return -1;
    }

    return;
    #else
    P2P_FRAME_WARN("need to do");
    #endif

}

wf_s32 p2p_invitation_request_to_issue_func(nic_info_st *nic_info, wf_u8 * raddr, wf_u8 flag)
{
#if 0
    unsigned char category = WL_WLAN_CATEGORY_PUBLIC;
    u8 action = P2P_PUB_ACTION_ACTION;
    u32 p2poui = cpu_to_be32(P2POUI);
    u8 oui_subtype = P2P_INVIT_REQ;
    u8 p2pie[255] = { 0x00 };
    u8 p2pielen = 0, i;
    u8 dialogToken = 3;
    u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
    u16 len_channellist_attr = 0;
#ifdef CONFIG_WFD
    u32 wfdielen = 0;
#endif
#ifdef CONFIG_CONCURRENT_MODE
    _wadptdata *pbuddy_wadptdata = pwadptdata->pbuddy_wadptdata;
    p2p_wd_info_st *pbuddy_wdinfo = &pbuddy_wadptdata->wdinfo;
    struct mlme_priv *pbuddy_mlmepriv = &pbuddy_wadptdata->mlmepriv;
    struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_wadptdata->mlmeextpriv;
#endif

    struct xmit_frame *pmgntframe;
    struct pkt_attrib *pattrib;
    unsigned char *pframe;
    struct wl_ieee80211_hdr *pwlanhdr;
    unsigned short *fctrl;
    struct xmit_priv *pxmitpriv = &(pwadptdata->xmitpriv);
    struct mlme_ext_priv *pmlmeext = &(pwadptdata->mlmeextpriv);
    struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
    p2p_wd_info_st *pwdinfo = &(pwadptdata->wdinfo);

    if ((pmgntframe = proc_alloc_mgtxmitframe_func(pxmitpriv)) == NULL) {
        return;
    }

    pattrib = &pmgntframe->attrib;
    proc_mgntframe_attrib_update_func(pwadptdata, pattrib);

    if (flag) {
        memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
    }
    pframe = (u8 *) (pmgntframe->buf_addr) + TXDESC_OFFSET;
    pwlanhdr = (struct wl_ieee80211_hdr *)pframe;

    fctrl = &(pwlanhdr->frame_ctl);
    *(fctrl) = 0;

    wf_memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
    wf_memcpy(pwlanhdr->addr2, wadptdata_mac_addr(pwadptdata), ETH_ALEN);
    wf_memcpy(pwlanhdr->addr3, raddr, ETH_ALEN);

    SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
    pmlmeext->mgnt_seq++;
    SetFrameSubType(pframe, WIFI_ACTION);

    pframe += sizeof(struct wl_ieee80211_hdr_3addr);
    pattrib->pktlen = sizeof(struct wl_ieee80211_hdr_3addr);

    pframe = fixed_ie_to_set_func(1, pframe, 1, &(category), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(action), &(pattrib->pktlen));
    pframe =
        fixed_ie_to_set_func(1, pframe, 4, (unsigned char *)&(p2poui),
                         &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(oui_subtype), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(dialogToken), &(pattrib->pktlen));

    p2pielen = 0;
    p2pie[p2pielen++] = 0x50;
    p2pie[p2pielen++] = 0x6F;
    p2pie[p2pielen++] = 0x9A;
    p2pie[p2pielen++] = 0x09;

    p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;

    *(u16 *) (p2pie + p2pielen) = cpu_to_le16(0x0002);
    p2pielen += 2;

    p2pie[p2pielen++] = 200;
    p2pie[p2pielen++] = 200;

    p2pie[p2pielen++] = P2P_ATTR_INVITATION_FLAGS;

    *(u16 *) (p2pie + p2pielen) = cpu_to_le16(0x0001);
    p2pielen += 2;

    p2pie[p2pielen++] = P2P_INVITATION_FLAGS_PERSISTENT;

    p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;

    *(u16 *) (p2pie + p2pielen) = cpu_to_le16(0x0005);
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

    if (pwdinfo->invitereq_info.operating_ch <= 14)
        p2pie[p2pielen++] = 0x51;

    p2pie[p2pielen++] = pwdinfo->invitereq_info.operating_ch;

    if (0 == wf_memcmp
        (wadptdata_mac_addr(pwadptdata), pwdinfo->invitereq_info.go_bssid,
         ETH_ALEN)) {
        p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;

        *(u16 *) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
        p2pielen += 2;

        wf_memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid,
                    ETH_ALEN);
        p2pielen += ETH_ALEN;
    }

    p2pie[p2pielen++] = P2P_ATTR_CH_LIST;

    len_channellist_attr = 3
        + (1 + 1) * (u16) p2p_info->channel_list.reg_classes
        + reg_classes_full_count_to_get_func(p2p_info->channel_list);

#ifdef CONFIG_CONCURRENT_MODE
    if (wf_p2p_check_buddy_linkstate(pwadptdata)
        && pwadptdata->registrypriv.full_ch_in_p2p_handshake == 0) {
        *(u16 *) (p2pie + p2pielen) = cpu_to_le16(5 + 1);
    } else {
        *(u16 *) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
    }
#else

    *(u16 *) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);

#endif
    p2pielen += 2;

    p2pie[p2pielen++] = 'X';
    p2pie[p2pielen++] = 'X';

    p2pie[p2pielen++] = 0x04;

#ifdef CONFIG_CONCURRENT_MODE
    if (wf_p2p_check_buddy_linkstate(pwadptdata)
        && pwadptdata->registrypriv.full_ch_in_p2p_handshake == 0) {
        _wadptdata *pbuddy_wadptdata = pwadptdata->pbuddy_wadptdata;
        struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_wadptdata->mlmeextpriv;

        if (pbuddy_mlmeext->cur_channel <= 14) {
            p2pie[p2pielen++] = 0x51;
        }

        p2pie[p2pielen++] = 1;

        p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
    } else {
        int i, j;
        for (j = 0; j < p2p_info->channel_list.reg_classes; j++) {
            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].reg_class;

            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].channels;

            for (i = 0; i < p2p_info->channel_list.reg_class[j].channels; i++) {
                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].channel[i];
            }
        }
    }
#else
    {
        int i, j;
        for (j = 0; j < p2p_info->channel_list.reg_classes; j++) {
            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].reg_class;

            p2pie[p2pielen++] = p2p_info->channel_list.reg_class[j].channels;

            for (i = 0; i < p2p_info->channel_list.reg_class[j].channels; i++) {
                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].channel[i];
            }
        }
    }
#endif

    p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;

    *(u16 *) (p2pie + p2pielen) =
        cpu_to_le16(6 + pwdinfo->invitereq_info.ssidlen);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid, ETH_ALEN);
    p2pielen += ETH_ALEN;

    wf_memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_ssid,
                pwdinfo->invitereq_info.ssidlen);
    p2pielen += pwdinfo->invitereq_info.ssidlen;

    p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;

    *(u16 *) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, wadptdata_mac_addr(pwadptdata), ETH_ALEN);
    p2pielen += ETH_ALEN;

    *(u16 *) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
    p2pielen += 2;

    *(u16 *) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
    p2pielen += 2;

    *(u32 *) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
    p2pielen += 4;

    *(u16 *) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
    p2pielen += 2;

    p2pie[p2pielen++] = 0x00;

    *(u16 *) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
    p2pielen += 2;

    *(u16 *) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
    p2pielen += 2;

    wf_memcpy(p2pie + p2pielen, pwdinfo->device_name,
                pwdinfo->device_name_len);
    p2pielen += pwdinfo->device_name_len;

    pframe =
        ie_to_set_func(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
                   (unsigned char *)p2pie, &pattrib->pktlen);

#ifdef CONFIG_WFD
    wfdielen = invitation_req_wfd_ie_build_func(pwdinfo, pframe, 1);
    pframe += wfdielen;
    pattrib->pktlen += wfdielen;
#endif

    pattrib->last_txcmdsz = pattrib->pktlen;

    mgntframe_to_dump_func(pwadptdata, pmgntframe);

    return;
#else
P2P_FRAME_WARN("need to do");

#endif
    return 0;
}

static void p2p_invitation_response_to_issue_func(nic_info_st * pnic_info, wf_u8 * raddr, wf_u8 dialogToken, wf_u8 status_code, wf_u8 flag)
{
#if 0
    unsigned char category = WL_WLAN_CATEGORY_PUBLIC;
    u8 action = P2P_PUB_ACTION_ACTION;
    u32 p2poui = cpu_to_be32(P2POUI);
    u8 oui_subtype = P2P_INVIT_RESP;
    u8 p2pie[255] = { 0x00 };
    u8 p2pielen = 0, i;
    u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
    u16 len_channellist_attr = 0;
#ifdef CONFIG_CONCURRENT_MODE
    _wadptdata *pbuddy_wadptdata = pwadptdata->pbuddy_wadptdata;
    p2p_wd_info_st *pbuddy_wdinfo = &pbuddy_wadptdata->wdinfo;
    struct mlme_priv *pbuddy_mlmepriv = &pbuddy_wadptdata->mlmepriv;
    struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_wadptdata->mlmeextpriv;
#endif
#ifdef CONFIG_WFD
    u32 wfdielen = 0;
#endif

    struct xmit_frame *pmgntframe;
    struct pkt_attrib *pattrib;
    unsigned char *pframe;
    struct wl_ieee80211_hdr *pwlanhdr;
    unsigned short *fctrl;
    struct xmit_priv *pxmitpriv = &(pwadptdata->xmitpriv);
    struct mlme_ext_priv *pmlmeext = &(pwadptdata->mlmeextpriv);
    struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
    p2p_wd_info_st *pwdinfo = &(pwadptdata->wdinfo);

    if ((pmgntframe = proc_alloc_mgtxmitframe_func(pxmitpriv)) == NULL) {
        return;
    }

    pattrib = &pmgntframe->attrib;
    proc_mgntframe_attrib_update_func(pwadptdata, pattrib);

    if (flag) {
        memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
    }
    pframe = (u8 *) (pmgntframe->buf_addr) + TXDESC_OFFSET;
    pwlanhdr = (struct wl_ieee80211_hdr *)pframe;

    fctrl = &(pwlanhdr->frame_ctl);
    *(fctrl) = 0;

    wf_memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
    wf_memcpy(pwlanhdr->addr2, wadptdata_mac_addr(pwadptdata), ETH_ALEN);
    wf_memcpy(pwlanhdr->addr3, raddr, ETH_ALEN);

    SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
    pmlmeext->mgnt_seq++;
    SetFrameSubType(pframe, WIFI_ACTION);

    pframe += sizeof(struct wl_ieee80211_hdr_3addr);
    pattrib->pktlen = sizeof(struct wl_ieee80211_hdr_3addr);

    pframe = fixed_ie_to_set_func(1, pframe, 1, &(category), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(action), &(pattrib->pktlen));
    pframe =
        fixed_ie_to_set_func(1, pframe, 4, (unsigned char *)&(p2poui),
                         &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(oui_subtype), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(dialogToken), &(pattrib->pktlen));

    p2pielen = 0;
    p2pie[p2pielen++] = 0x50;
    p2pie[p2pielen++] = 0x6F;
    p2pie[p2pielen++] = 0x9A;
    p2pie[p2pielen++] = 0x09;

    p2pie[p2pielen++] = P2P_ATTR_STATUS;

    *(u16 *) (p2pie + p2pielen) = cpu_to_le16(0x0001);
    p2pielen += 2;

    p2pie[p2pielen++] = status_code;

    p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;

    *(u16 *) (p2pie + p2pielen) = cpu_to_le16(0x0002);
    p2pielen += 2;

    p2pie[p2pielen++] = 200;
    p2pie[p2pielen++] = 200;

    if (status_code == P2P_STATUS_SUCCESS) {
        if (wl_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {

            p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;

            *(u16 *) (p2pie + p2pielen) = cpu_to_le16(0x0005);
            p2pielen += 2;

            p2pie[p2pielen++] = 'X';
            p2pie[p2pielen++] = 'X';

            p2pie[p2pielen++] = 0x04;

            p2pie[p2pielen++] = 0x51;

            p2pie[p2pielen++] = pwdinfo->operating_channel;

            p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;

            *(u16 *) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
            p2pielen += 2;

            wf_memcpy(p2pie + p2pielen, wadptdata_mac_addr(pwadptdata), ETH_ALEN);
            p2pielen += ETH_ALEN;

        }

        p2pie[p2pielen++] = P2P_ATTR_CH_LIST;

        len_channellist_attr = 3
            + (1 + 1) * (u16) p2p_info->channel_list.reg_classes
            + reg_classes_full_count_to_get_func(p2p_info->channel_list);

#ifdef CONFIG_CONCURRENT_MODE
        if (wf_p2p_check_buddy_linkstate(pwadptdata)
            && pwadptdata->registrypriv.full_ch_in_p2p_handshake == 0) {
            *(u16 *) (p2pie + p2pielen) = cpu_to_le16(5 + 1);
        } else {
            *(u16 *) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
        }
#else

        *(u16 *) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);

#endif
        p2pielen += 2;

        p2pie[p2pielen++] = 'X';
        p2pie[p2pielen++] = 'X';

        p2pie[p2pielen++] = 0x04;

#ifdef CONFIG_CONCURRENT_MODE
        if (wf_p2p_check_buddy_linkstate(pwadptdata)
            && pwadptdata->registrypriv.full_ch_in_p2p_handshake == 0) {
            _wadptdata *pbuddy_wadptdata = pwadptdata->pbuddy_wadptdata;
            struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_wadptdata->mlmeextpriv;

            if (pbuddy_mlmeext->cur_channel <= 14) {
                p2pie[p2pielen++] = 0x51;
            }

            p2pie[p2pielen++] = 1;

            p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
        } else {
            int i, j;
            for (j = 0; j < p2p_info->channel_list.reg_classes; j++) {
                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].reg_class;

                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].channels;

                for (i = 0; i < p2p_info->channel_list.reg_class[j].channels;
                     i++) {
                    p2pie[p2pielen++] =
                        p2p_info->channel_list.reg_class[j].channel[i];
                }
            }
        }
#else
        {
            int i, j;
            for (j = 0; j < p2p_info->channel_list.reg_classes; j++) {
                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].reg_class;

                p2pie[p2pielen++] =
                    p2p_info->channel_list.reg_class[j].channels;

                for (i = 0; i < p2p_info->channel_list.reg_class[j].channels;
                     i++) {
                    p2pie[p2pielen++] =
                        p2p_info->channel_list.reg_class[j].channel[i];
                }
            }
        }
#endif
    }

    pframe =
        ie_to_set_func(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
                   (unsigned char *)p2pie, &pattrib->pktlen);

#ifdef CONFIG_WFD
    wfdielen = invitation_resp_wfd_ie_build_func(pwdinfo, pframe, 1);
    pframe += wfdielen;
    pattrib->pktlen += wfdielen;
#endif

    pattrib->last_txcmdsz = pattrib->pktlen;

    mgntframe_to_dump_func(pwadptdata, pmgntframe);

    return;
#else
P2P_FRAME_WARN("need to do");
#endif
}

static void p2p_presence_resp_issue_func(nic_info_st *pnic_info, wf_u8 * da, wf_u8 status, wf_u8 dialogToken, wf_u8 flag)
{
#if 0
    struct xmit_frame *pmgntframe;
    struct pkt_attrib *pattrib;
    unsigned char *pframe;
    struct wl_ieee80211_hdr *pwlanhdr;
    unsigned short *fctrl;
    _wadptdata *pwadptdata = pwdinfo->pwadptdata;
    struct xmit_priv *pxmitpriv = &(pwadptdata->xmitpriv);
    struct mlme_ext_priv *pmlmeext = &(pwadptdata->mlmeextpriv);
    unsigned char category = WL_WLAN_CATEGORY_P2P;
    u32 p2poui = cpu_to_be32(P2POUI);
    u8 oui_subtype = P2P_PRESENCE_RESPONSE;
    u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
    u8 noa_attr_content[32] = { 0x00 };
    u32 p2pielen = 0;

    P2P_FRAME_INFO("[%s]\n", __FUNCTION__);

    if ((pmgntframe = proc_alloc_mgtxmitframe_func(pxmitpriv)) == NULL) {
        return;
    }

    pattrib = &pmgntframe->attrib;
    proc_mgntframe_attrib_update_func(pwadptdata, pattrib);

    if (flag) {
        memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
    }
    pframe = (u8 *) (pmgntframe->buf_addr) + TXDESC_OFFSET;
    pwlanhdr = (struct wl_ieee80211_hdr *)pframe;

    fctrl = &(pwlanhdr->frame_ctl);
    *(fctrl) = 0;

    wf_memcpy(pwlanhdr->addr1, da, ETH_ALEN);
    wf_memcpy(pwlanhdr->addr2, pwdinfo->interface_addr, ETH_ALEN);
    wf_memcpy(pwlanhdr->addr3, pwdinfo->interface_addr, ETH_ALEN);

    SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
    pmlmeext->mgnt_seq++;
    SetFrameSubType(pframe, WIFI_ACTION);

    pframe += sizeof(struct wl_ieee80211_hdr_3addr);
    pattrib->pktlen = sizeof(struct wl_ieee80211_hdr_3addr);

    pframe = fixed_ie_to_set_func(1, pframe, 1, &(category), &(pattrib->pktlen));
    pframe =
        fixed_ie_to_set_func(1, pframe, 4, (unsigned char *)&(p2poui),
                         &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(oui_subtype), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(dialogToken), &(pattrib->pktlen));

    p2pielen = 0;
    p2pie[p2pielen++] = 0x50;
    p2pie[p2pielen++] = 0x6F;
    p2pie[p2pielen++] = 0x9A;
    p2pie[p2pielen++] = 0x09;

    p2pielen += p2p_attr_content_to_set_func(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status,1);

    noa_attr_content[0] = 0x1;
    noa_attr_content[1] = 0x0;

    p2pielen += p2p_attr_content_to_set_func(&p2pie[p2pielen], P2P_ATTR_NOA, 2, noa_attr_content, 1);

    pframe = ie_to_set_func(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, p2pie, &(pattrib->pktlen));

    pattrib->last_txcmdsz = pattrib->pktlen;

    mgntframe_to_dump_func(pwadptdata, pmgntframe);
#else
    P2P_FRAME_WARN("need to do");
#endif

}

wf_s32 p2p_presence_req_process_func(nic_info_st *pnic_info, wf_u8 * pframe,wf_s32 len, wf_u8 flag)
{
    wf_u8 *frame_body;
    wf_u8 dialogToken = 0;
    wf_u8 status = P2P_STATUS_SUCCESS;
    p2p_wd_info_st * pwdinfo = NULL;
    p2p_info_st *p2p_info = NULL;

    if(NULL == pnic_info)
    {
        P2P_FRAME_WARN("input param is null");
        return WF_RETURN_FAIL;
    }
    p2p_info = pnic_info->p2p;
    pwdinfo = &p2p_info->wdinfo;
    frame_body =(wf_u8 *)(pframe + sizeof(struct wl_ieee80211_hdr_3addr));

    dialogToken = frame_body[6];

    if (flag) 
    {
        p2p_presence_resp_issue_func(pnic_info, GetAddr2Ptr(pframe), status,dialogToken, 1);
    }
    return WF_RETURN_OK;
}

static void p2p_provision_resp_issue_func(nic_info_st *pnic_info,wf_u8 *raddr, wf_u8 * frame_body, wf_u16 config_method, wf_u8 flag)
{
#if 0
    _wadptdata *pwadptdata = pwdinfo->pwadptdata;
    unsigned char category = WL_WLAN_CATEGORY_PUBLIC;
    u8 action = P2P_PUB_ACTION_ACTION;
    u8 dialogToken = frame_body[7];
    u32 p2poui = cpu_to_be32(P2POUI);
    u8 oui_subtype = P2P_PROVISION_DISC_RESP;
    u8 wpsie[100] = { 0x00 };
    u8 wpsielen = 0;
    p2p_info_st *p2p_info = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;
#ifdef CONFIG_WFD
    u32 wfdielen = 0;
#endif

    struct xmit_frame *pmgntframe;
    struct pkt_attrib *pattrib;
    unsigned char *pframe;
    struct wl_ieee80211_hdr *pwlanhdr;
    unsigned short *fctrl;
    struct xmit_priv *pxmitpriv = &(pwadptdata->xmitpriv);
    struct mlme_ext_priv *pmlmeext = &(pwadptdata->mlmeextpriv);
    struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);

    if ((pmgntframe = proc_alloc_mgtxmitframe_func(pxmitpriv)) == NULL) {
        return;
    }

    pattrib = &pmgntframe->attrib;
    proc_mgntframe_attrib_update_func(pwadptdata, pattrib);

    if (flag) {
        memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
    }
    pframe = (u8 *) (pmgntframe->buf_addr) + TXDESC_OFFSET;
    pwlanhdr = (struct wl_ieee80211_hdr *)pframe;

    fctrl = &(pwlanhdr->frame_ctl);
    *(fctrl) = 0;

    wf_memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
    wf_memcpy(pwlanhdr->addr2, wadptdata_mac_addr(pwadptdata), ETH_ALEN);
    wf_memcpy(pwlanhdr->addr3, wadptdata_mac_addr(pwadptdata), ETH_ALEN);

    SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
    pmlmeext->mgnt_seq++;
    SetFrameSubType(pframe, WIFI_ACTION);

    pframe += sizeof(struct wl_ieee80211_hdr_3addr);
    pattrib->pktlen = sizeof(struct wl_ieee80211_hdr_3addr);

    pframe = fixed_ie_to_set_func(1, pframe, 1, &(category), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(action), &(pattrib->pktlen));
    pframe =
        fixed_ie_to_set_func(1, pframe, 4, (unsigned char *)&(p2poui),
                         &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(oui_subtype), &(pattrib->pktlen));
    pframe = fixed_ie_to_set_func(1, pframe, 1, &(dialogToken), &(pattrib->pktlen));

    wpsielen = 0;
    WL_PUT_BE32(wpsie, WPSOUI);
    wpsielen += 4;

    WL_PUT_BE16(wpsie + wpsielen, WPS_ATTR_CONF_METHOD);
    wpsielen += 2;

    WL_PUT_BE16(wpsie + wpsielen, 0x0002);
    wpsielen += 2;

    WL_PUT_BE16(wpsie + wpsielen, config_method);
    wpsielen += 2;

    pframe =
        ie_to_set_func(pframe, _VENDOR_SPECIFIC_IE_, wpsielen,
                   (unsigned char *)wpsie, &pattrib->pktlen);

#ifdef CONFIG_WFD
    wfdielen = provdisc_resp_wfd_ie_build_func(pwdinfo, pframe, 1);
    pframe += wfdielen;
    pattrib->pktlen += wfdielen;
#endif

    pattrib->last_txcmdsz = pattrib->pktlen;

    mgntframe_to_dump_func(pwadptdata, pmgntframe);

    return;
#endif
}

wf_u32 p2p_devdisc_req_process_func(nic_info_st *pnic_info, wf_u8 * pframe,wf_u32 len, wf_u8 flag)
{
    #if 0
    wf_u8 *frame_body;
    wf_u8 status, dialogToken;
    struct sta_info *psta = NULL;
    _wadptdata *pwadptdata = pwdinfo->pwadptdata;
    struct sta_priv *pstapriv = &pwadptdata->stapriv;
    wf_u8 *p2p_ie;
    wf_u32 p2p_ielen = 0;
    p2p_info_st *p2p_info = pnic_info->p2p;
    p2p_wd_info_st * pwdinfo = &p2p_info->wdinfo;
    frame_body = (unsigned char *)(pframe + sizeof(struct wl_ieee80211_hdr_3addr));

    dialogToken = frame_body[7];
    status = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;

    if ((p2p_ie =p2p_ie_to_get_func(frame_body + WF_PUBLIC_ACTION_IE_OFFSET,len - WF_PUBLIC_ACTION_IE_OFFSET, NULL, &p2p_ielen))) 
    {
        wf_u8 groupid[38] = { 0x00 };
        wf_u8 dev_addr[WF_ETH_ALEN] = { 0x00 };
        wf_u32 attr_contentlen = 0;

        if (p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen)) 
        {
            if (0 == wf_memcmp(pwdinfo->device_addr, groupid, WF_ETH_ALEN)
                && 0 == wf_memcmp(pwdinfo->p2p_group_ssid, groupid + WF_ETH_ALEN,pwdinfo->p2p_group_ssid_len)) 
            {
                attr_contentlen = 0;
                if (p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_ID, dev_addr,&attr_contentlen)) 
                {
                    _irqL irqL;
                    _list *phead, *plist;

                    spin_lock_bh(&pstapriv->asoc_list_lock);
                    phead = &pstapriv->asoc_list;
                    plist = get_next(phead);

                    while ((Func_Of_Proc_End_Of_Queue_Search(phead, plist)) == _FALSE) {
                        psta =
                            LIST_CONTAINOR(plist, struct sta_info, asoc_list);

                        plist = get_next(plist);

                        if (psta->is_p2p_device
                            && (psta->dev_cap & P2P_DEVCAP_CLIENT_DISCOVERABILITY)
                            && 0 == wf_memcmp(psta->dev_addr, dev_addr,WF_ETH_ALEN)) {

                            group_disc_req_issue_func(pwdinfo, psta->hwaddr, 1);

                            status = P2P_STATUS_SUCCESS;

                            break;
                        } else {
                            status = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
                        }

                    }
                    spin_unlock_bh(&pstapriv->asoc_list_lock);

                } else {
                    status = P2P_STATUS_FAIL_INVALID_PARAM;
                }

            } else {
                status = P2P_STATUS_FAIL_INVALID_PARAM;
            }

        }

    }

    if (flag) 
    {
        p2p_devdisc_resp_issue_func(pwdinfo, GetAddr2Ptr(pframe), status,dialogToken, 1);
    }

    return (status == P2P_STATUS_SUCCESS) ? _TRUE : _FALSE;
    #endif
    
    return wf_true;
}

wf_bool p2p_devdisc_resp_process_func(nic_info_st *pnic_info, wf_u8 * pframe,wf_u32 len, wf_u8 flag)
{
    return wf_true;
}

wf_u8 p2p_provdisc_req_process_func(nic_info_st *pnic_info, wf_u8 * pframe,wf_u32 len, wf_u8 flag)
{
    wf_u8 *frame_body       = NULL;
    wf_u8 *wpsie            = NULL;
    wf_u32 wps_ielen        = 0;
    wf_u32 attr_contentlen  = 0;
    wf_u16 uconfig_method   = 0;
    p2p_info_st *p2p_info   = pnic_info->p2p;
    p2p_wd_info_st * pwdinfo = &p2p_info->wdinfo;
    
    frame_body = (pframe + sizeof(struct wl_ieee80211_hdr_3addr));

    if ((wpsie = wf_wlan_get_wps_ie(frame_body + WF_PUBLIC_ACTION_IE_OFFSET ,len - WF_PUBLIC_ACTION_IE_OFFSET, NULL, &wps_ielen))) 
    {
        if (wf_wlan_get_wps_attr_content(1, wpsie, wps_ielen, WPS_ATTR_CONF_METHOD, (wf_u8 *) & uconfig_method,
             &attr_contentlen)) {
            uconfig_method = wf_be16_to_cpu(uconfig_method);
            switch (uconfig_method) {
            case WPS_CM_DISPLYA:
                {
                    wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis",3);
                    break;
                }
            case WPS_CM_LABEL:
                {
                    wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "lab",3);
                    break;
                }
            case WPS_CM_PUSH_BUTTON:
                {
                    wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc",3);
                    break;
                }
            case WPS_CM_KEYPAD:
                {
                    wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad",3);
                    break;
                }
            }
            if (flag) 
            {
                p2p_provision_resp_issue_func(pnic_info, GetAddr2Ptr(pframe),frame_body, uconfig_method, 1);
            }
        }
    }
    
    P2P_FRAME_INFO("[%s] config method = %s\n", __FUNCTION__,pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req);
    
    return wf_true;
}

wf_bool p2p_provdisc_resp_process_func(nic_info_st *pnic_info, wf_u8 * pframe, wf_u8 flag)
{

    return wf_true;
}

wf_s32 probereq_p2p_to_issue_func(nic_info_st *pnic_info, wf_u8 * da, wf_s32 wait_ack, wf_u8 flag)
{
    tx_info_st *ptx_info        = (tx_info_st *)pnic_info->tx_info;
    struct xmit_buf *pxmit_buf  = NULL;
    wf_80211_mgmt_t *pframe     = NULL;
    wf_u32 var_len              = 0;
    wf_u8 *pvar                 = NULL;
    p2p_info_st *p2p_info       = pnic_info->p2p;
    p2p_wd_info_st *pwd = &p2p_info->wdinfo;

    /* alloc xmit_buf */
    pxmit_buf = wf_xmit_extbuf_new(ptx_info);
    if (pxmit_buf == NULL)
    {
        LOG_W("pxmit_buf is NULL");
        return -1;
    }

    /* set frame head */
    wf_memset(pxmit_buf->pbuf, 0,TXDESC_OFFSET + WF_OFFSETOF(wf_80211_mgmt_t, probe_req));
    pframe = (void *)&pxmit_buf->pbuf[TXDESC_OFFSET];

    /* set control field */
    wf_80211_set_frame_type(&pframe->frame_control, WF_80211_STYPE_PROBE_REQ);

    /* set address field */
    if(da)
    {
        wf_memcpy((void*)pframe->da, (void*)da, sizeof(pframe->da));
        wf_memcpy(pframe->sa, nic_to_local_addr(pnic_info), sizeof(pframe->sa));
        wf_memcpy((void*)pframe->bssid, (void*)da, sizeof(pframe->bssid));
    }
    else
    {
        wf_memset(pframe->da, 0xff, sizeof(pframe->da));
        wf_memcpy(pframe->sa, nic_to_local_addr(pnic_info), sizeof(pframe->sa));
        wf_memset(pframe->bssid, 0xff, sizeof(pframe->bssid));
    }
//    SCAN_DBG("SA="WF_MAC_FMT, WF_MAC_ARG(pframe->da));
//    SCAN_DBG("DA="WF_MAC_FMT, WF_MAC_ARG(pframe->sa));
//    SCAN_DBG("BSSID="WF_MAC_FMT, WF_MAC_ARG(pframe->bssid));

    /* set variable field */
    var_len = 0;
    pvar = &pframe->probe_req.variable[0];
    /*1.SSID*/
    if(pwd->p2p_state == P2P_STATE_TX_PROVISION_DIS_REQ)
    {
        pvar = set_ie(pvar, PROBE_REQUEST_IE_SSID,
                      pwd->tx_prov_disc_info.ssidlen, pwd->tx_prov_disc_info.ssid,
                      &var_len);
    }
    else
    {
        P2P_FRAME_DBG("[%d] p2p_wildcard_ssid:%s",pnic_info->ndev_id,pwd->p2p_wildcard_ssid);
        pvar = set_ie(pvar, PROBE_REQUEST_IE_SSID, P2P_WILDCARD_SSID_LEN, pwd->p2p_wildcard_ssid,&var_len);
    }
    /*2.Supported Rates and BSS Membership Selectors*/
    pvar = set_ie(pvar, PROBE_REQUEST_IE_RATE, 8, &pwd->p2p_support_rate[0], &var_len);

    /*4. wps ie and p2p ie*/
    {
        if(pwd->driver_interface == DRIVER_CFG80211)
        {
#ifdef CONFIG_IOCTL_CFG80211 // for compatibility with windows compile
            mlme_info_t *mlme_info = pnic_info->mlme_info;
            if(mlme_info && mlme_info->probereq_wps_ie && mlme_info->wps_ie_len)
            {
                //P2P_FRAME_DBG("[%d] wps_ie_len:%d",pnic_info->ndev_id,mlme_info->wps_ie_len);
                wf_memcpy(pvar,mlme_info->probereq_wps_ie,mlme_info->wps_ie_len);
                var_len += mlme_info->wps_ie_len;
                pvar+=mlme_info->wps_ie_len;
            }
#endif

            if(p2p_info->p2p_ie[WF_P2P_IE_PROBE_REQ] && p2p_info->p2p_ie_len[WF_P2P_IE_PROBE_REQ])
            {
                //P2P_FRAME_DBG("[%d]  p2p_probe_req_ie_len:%d",pnic_info->ndev_id,p2p_info->p2p_probe_req_ie_len);
                wf_memcpy(pvar,p2p_info->p2p_ie[WF_P2P_IE_PROBE_REQ],p2p_info->p2p_ie_len[WF_P2P_IE_PROBE_REQ]);
                var_len += p2p_info->p2p_ie_len[WF_P2P_IE_PROBE_REQ];
                pvar+=p2p_info->p2p_ie_len[WF_P2P_IE_PROBE_REQ];
            }
        }
        else
        {

        }
    }

    /* frame send */
    pxmit_buf->pkt_len = WF_OFFSETOF(wf_80211_mgmt_t, probe_req.variable) + var_len;
    if (wf_nic_mgmt_frame_xmit(pnic_info, NULL, pxmit_buf, pxmit_buf->pkt_len))
    {
        LOG_W("probe frame send fail");
        return -1;
    }
    return 0;
}

wf_s32 probereq_p2p_to_pre_issue_func(nic_info_st *nic_info, wf_u8 * da)
{
    return probereq_p2p_to_issue_func(nic_info, da, wf_false, 1);
}
/*
*p2p rx frame handle of probereq
*
*/
wf_s32 probe_req_p2p_ie_process_func(p2p_wd_info_st * pwdinfo, wf_u8 * probereq_ie, wf_u16 len, wf_u8 flag)
{
    wf_u8 *p;
    wf_s32 ret = -1;
    wf_u8 *p2pie;
    wf_u32 p2pielen = 0;
    wf_s32 ssid_len = 0, rate_cnt = 0;

    //P2P_DBUG;

    p = wf_wlan_get_ie(probereq_ie, WF_80211_MGMT_EID_SUPP_RATES, (wf_s32 *)&rate_cnt, len - WLAN_HDR_A3_LEN);

    if (rate_cnt <= 4) {
        wf_s32 i, g_rate = 0;

        for (i = 0; i < rate_cnt; i++) {
            if (((*(p + 2 + i) & 0xff) != 0x02) &&
                ((*(p + 2 + i) & 0xff) != 0x04) &&
                ((*(p + 2 + i) & 0xff) != 0x0B) &&
                ((*(p + 2 + i) & 0xff) != 0x16)) {
                g_rate = 1;
            }
        }

        if (g_rate == 0) {
            return ret;
        }
    } else {
    }

    p = wf_wlan_get_ie(probereq_ie , WF_80211_MGMT_EID_SSID,(wf_s32 *)&ssid_len, len - WLAN_HDR_A3_LEN);

    if (flag) {
        ssid_len &= 0xff;
    }
    if ( (pwdinfo->role == P2P_ROLE_DEVICE)||(pwdinfo->role == P2P_ROLE_GO))
        {
        if ((p2pie = p2p_ie_to_get_func(probereq_ie,len - WLAN_HDR_A3_LEN , NULL,&p2pielen)))
            {
            if ((p != NULL)&& (wf_memcmp((void *)(p + 2),(void *)pwdinfo->p2p_wildcard_ssid, 7) == 0))
            {
                ret = 0;
            } else if ((p != NULL) && (ssid_len == 0)) {
                ret = 0;
            }
        } else {
        }

    }

    return ret;

}



wf_s32 probersp_p2p_to_issue_func(nic_info_st *pnic_info, unsigned char *da, wf_u8 flag)
{
    tx_info_st *ptx_info        = (tx_info_st *)pnic_info->tx_info;
    struct xmit_buf *pxmit_buf  = NULL;
    wf_80211_mgmt_t *pframe     = NULL;
//    wf_scan_info_t *pscan_info     = pnic_info->scan_info;
//    hw_info_st *hw_info         = pnic_info->hw_info;
    wf_u32 var_len              = 0;
    wf_u8 *pvar                 = NULL;
    p2p_info_st *p2p_info       = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;
//    wf_wlan_mgmt_info_t *pwlan_info = pnic_info->wlan_mgmt_info;
#ifdef CONFIG_IOCTL_CFG80211
    mlme_info_t *pmlme_info = (mlme_info_t *)pnic_info->mlme_info;
#endif
    wf_u16 beacon_interval = 100;
    wf_u16 capInfo = 0;
    wf_u8 wpsie[255] = { 0x00 };
    wf_u32 wpsielen = 0, p2pielen = 0;
#ifdef CONFIG_WFD
 //   wf_u32 wfdielen = 0;
#endif

    /* aclloc xmit buf*/
    pxmit_buf = wf_xmit_extbuf_new(ptx_info);
    if(pxmit_buf == NULL)
    {
        P2P_FRAME_WARN("[%s]%d: pxmit_buf aclloc failed ",__func__,__LINE__);
        return -1;
    }

    /*set frame head */
    wf_memset(pxmit_buf->pbuf, 0, TXDESC_OFFSET + WF_OFFSETOF(wf_80211_mgmt_t, probe_resp));
    pframe = (void *)&pxmit_buf->pbuf[TXDESC_OFFSET];

    /*set control field*/
    wf_80211_set_frame_type(&pframe->frame_control, WF_80211_STYPE_PROBE_RESP);
    pframe->frame_control = wf_cpu_to_le16(pframe->frame_control);

    /*set address*/
    wf_memcpy((void*)pframe->da, (void*)da, sizeof(pframe->da));
    wf_memcpy((void*)pframe->sa, nic_to_local_addr(pnic_info), sizeof(pframe->sa));
    wf_memcpy((void*)pframe->bssid, nic_to_local_addr(pnic_info), sizeof(pframe->bssid));

    /*set pies fiexd field */
    pframe->probe_resp.intv = beacon_interval;

    capInfo |= BIT(5);  //cap_ShortPremble
    capInfo |= BIT(10); //cap_ShortSlot
    pframe->probe_resp.capab = capInfo;

    /*set variable filed*/
    pvar = &pframe->probe_resp.variable[0];

    pvar = set_ie(pvar, WF_80211_MGMT_EID_SSID, 7, pwdinfo->p2p_wildcard_ssid,&var_len);

    pvar =set_ie(pvar, WF_80211_MGMT_EID_SUPP_RATES, 8,&pwdinfo->p2p_support_rate[0], &var_len);

    pvar =set_ie(pvar, WF_80211_MGMT_EID_DS_PARAMS, 1,(unsigned char *)&pwdinfo->listen_channel, &var_len);

#ifdef CONFIG_IOCTL_CFG80211
        if (p2p_info->p2p_enabled
            && pwdinfo->driver_interface == DRIVER_CFG80211) {
            if (pmlme_info->wps_probe_resp_ie != NULL
                && p2p_info->p2p_ie[WF_P2P_IE_PROBE_RSP] != NULL) {
                P2P_FRAME_INFO("[%s]%d:p2p probersp CONFIG_IOCTL_CFG80211 send ",__func__,__LINE__);
                wf_memcpy(pvar, pmlme_info->wps_probe_resp_ie,pmlme_info->wps_probe_resp_ie_len);
                var_len += pmlme_info->wps_probe_resp_ie_len;
                pvar += pmlme_info->wps_probe_resp_ie_len;

                wf_memcpy(pvar, p2p_info->p2p_ie[WF_P2P_IE_PROBE_RSP],p2p_info->p2p_ie_len[WF_P2P_IE_PROBE_RSP]);
                var_len += p2p_info->p2p_ie_len[WF_P2P_IE_PROBE_RSP];
                pvar += p2p_info->p2p_ie_len[WF_P2P_IE_PROBE_RSP];
            }
        } 
        else
#endif

         {

            P2P_FRAME_INFO("start");
            wpsielen = 0;
            *(wf_u32 *) (wpsie) = wf_cpu_to_be32(WPSOUI);
            wpsielen += 4;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_VER1);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
            wpsielen += 2;

            wpsie[wpsielen++] = WPS_VERSION_1;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_SIMPLE_CONF_STATE);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
            wpsielen += 2;

            wpsie[wpsielen++] = WPS_WSC_STATE_NOT_CONFIG;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_RESP_TYPE);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
            wpsielen += 2;

            wpsie[wpsielen++] = WPS_RESPONSE_TYPE_8021X;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_UUID_E);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0010);
            wpsielen += 2;

            if (pwdinfo->external_uuid == 0) {
                wf_memset(wpsie + wpsielen, 0x0, 16);
                wf_memcpy(wpsie + wpsielen, nic_to_local_addr(pnic_info), WF_ETH_ALEN);
            } else {
                wf_memcpy(wpsie + wpsielen, pwdinfo->uuid, 0x10);
            }
            wpsielen += 0x10;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_MANUFACTURER);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0007);
            wpsielen += 2;

            wf_memcpy(wpsie + wpsielen, "Wf_wlan", 7);
            wpsielen += 7;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_MODEL_NAME);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0006);
            wpsielen += 2;

            wf_memcpy(wpsie + wpsielen, "9192CU", 6);
            wpsielen += 6;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_MODEL_NUMBER);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
            wpsielen += 2;

            wpsie[wpsielen++] = 0x31;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_SERIAL_NUMBER);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WF_ETH_ALEN);
            wpsielen += 2;

            wf_memcpy(wpsie + wpsielen, "123456", WF_ETH_ALEN);
            wpsielen += WF_ETH_ALEN;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0008);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
            wpsielen += 2;

            *(wf_u32 *) (wpsie + wpsielen) = wf_cpu_to_be32(WPSOUI);
            wpsielen += 4;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_DEVICE_NAME);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(pwdinfo->device_name_len);
            wpsielen += 2;

            wf_memcpy(wpsie + wpsielen, pwdinfo->device_name, pwdinfo->device_name_len);
            wpsielen += pwdinfo->device_name_len;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_CONF_METHOD);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0002);
            wpsielen += 2;

            *(wf_u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(pwdinfo->supported_wps_cm);
            wpsielen += 2;

            pvar = set_ie(pvar, WF_80211_MGMT_EID_VENDOR_SPECIFIC, wpsielen,(unsigned char *)wpsie, &var_len);

            p2pielen = probe_resp_p2p_ie_build_func(pnic_info, pvar, 1);
            pvar += p2pielen;
            var_len += p2pielen;
        }

/*
#ifdef CONFIG_WFD
        wfdielen = probe_resp_wfd_ie_to_append_func(nic_info, pframe, 1);
        pframe += wfdielen;
        pattrib->pktlen += wfdielen;
#endif
*/
    /*frame send*/
    pxmit_buf->pkt_len = WF_OFFSETOF(wf_80211_mgmt_t, probe_resp.variable) + var_len;
    P2P_FRAME_ARRAY(pframe,pxmit_buf->pkt_len);
//    P2P_FRAME_DBG("[%d] p2p probersp frame send  pkt_len=%d",pnic_info->ndev_id, pxmit_buf->pkt_len);

    if (wf_nic_mgmt_frame_xmit(pnic_info, NULL, pxmit_buf, pxmit_buf->pkt_len))
    {
        LOG_W("p2p probersp frame send fail");
        return -1;
    }

        return 0;


    /*
    struct xmit_frame *pmgntframe;
    struct pkt_attrib *pattrib;
    unsigned char *pframe;
    struct wl_ieee80211_hdr *pwlanhdr;
    unsigned short *fctrl;
    unsigned char *mac;
    struct xmit_priv *pxmitpriv = &(nic_info->xmitpriv);
    struct mlme_ext_priv *pmlmeext = &(nic_info->mlmeextpriv);
    struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
    struct mlme_priv *pmlmepriv = &(nic_info->mlmepriv);
    u16 beacon_interval = 100;
    u16 capInfo = 0;
    p2p_wd_info_st *pwdinfo = &(nic_info->wdinfo);
    u8 wpsie[255] = { 0x00 };
    u32 wpsielen = 0, p2pielen = 0;
#ifdef CONFIG_WFD
    u32 wfdielen = 0;
#endif

    P2P_DBUG;


    if ((pmgntframe = proc_alloc_mgtxmitframe_func(pxmitpriv)) == NULL) {
        return;
    }

    pattrib = &pmgntframe->attrib;
    proc_mgntframe_attrib_update_func(nic_info, pattrib);
    if (flag) {
        memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
    }
    pframe = (u8 *) (pmgntframe->buf_addr) + TXDESC_OFFSET;
    pwlanhdr = (struct wl_ieee80211_hdr *)pframe;

    mac = nic_to_local_addr(nic_info);

    fctrl = &(pwlanhdr->frame_ctl);
    *(fctrl) = 0;
    wf_memcpy(pwlanhdr->addr1, da, WF_ETH_ALEN);
    wf_memcpy(pwlanhdr->addr2, mac, WF_ETH_ALEN);

    wf_memcpy(pwlanhdr->addr3, mac, WF_ETH_ALEN);

    SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
    pmlmeext->mgnt_seq++;
    SetFrameSubType(fctrl, WIFI_PROBERSP);

    pattrib->hdrlen = sizeof(struct wl_ieee80211_hdr_3addr);
    pattrib->pktlen = pattrib->hdrlen;
    pframe += pattrib->hdrlen;

    pframe += 8;
    pattrib->pktlen += 8;

    wf_memcpy(pframe, (unsigned char *)&beacon_interval, 2);
    pframe += 2;
    pattrib->pktlen += 2;

    capInfo |= cap_ShortPremble;
    capInfo |= cap_ShortSlot;

    wf_memcpy(pframe, (unsigned char *)&capInfo, 2);
    pframe += 2;
    pattrib->pktlen += 2;

    pframe =
        set_ie(pframe, _SSID_IE_, 7, pwdinfo->p2p_wildcard_ssid,
                   &pattrib->pktlen);

    pframe =
        set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate,
                   &pattrib->pktlen);

    pframe =
        set_ie(pframe, _DSSET_IE_, 1,
                   (unsigned char *)&pwdinfo->listen_channel, &pattrib->pktlen);

#ifdef CONFIG_IOCTL_CFG80211
    if (wadptdata_wdev_data(nic_info)->p2p_enabled
        && pwdinfo->driver_interface == DRIVER_CFG80211) {
        if (pmlmepriv->wps_probe_resp_ie != NULL
            && pmlmepriv->p2p_probe_resp_ie != NULL) {
            wf_memcpy(pframe, pmlmepriv->wps_probe_resp_ie,
                        pmlmepriv->wps_probe_resp_ie_len);
            pattrib->pktlen += pmlmepriv->wps_probe_resp_ie_len;
            pframe += pmlmepriv->wps_probe_resp_ie_len;

            wf_memcpy(pframe, pmlmepriv->p2p_probe_resp_ie,
                        pmlmepriv->p2p_probe_resp_ie_len);
            pattrib->pktlen += pmlmepriv->p2p_probe_resp_ie_len;
            pframe += pmlmepriv->p2p_probe_resp_ie_len;
        }
    } else
#endif
    {

        wpsielen = 0;
        *(u32 *) (wpsie) = wf_cpu_to_be32(WPSOUI);
        wpsielen += 4;

        *(u16 *) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
        wpsielen += 2;

        wpsie[wpsielen++] = WPS_VERSION_1;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_SIMPLE_CONF_STATE);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
        wpsielen += 2;

        wpsie[wpsielen++] = WPS_WSC_STATE_NOT_CONFIG;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_RESP_TYPE);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
        wpsielen += 2;

        wpsie[wpsielen++] = WPS_RESPONSE_TYPE_8021X;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_UUID_E);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0010);
        wpsielen += 2;

        if (pwdinfo->external_uuid == 0) {
            memset(wpsie + wpsielen, 0x0, 16);
            wf_memcpy(wpsie + wpsielen, mac, WF_ETH_ALEN);
        } else {
            wf_memcpy(wpsie + wpsielen, pwdinfo->uuid, 0x10);
        }
        wpsielen += 0x10;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_MANUFACTURER);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0007);
        wpsielen += 2;

        wf_memcpy(wpsie + wpsielen, "Wf_wlan", 7);
        wpsielen += 7;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_MODEL_NAME);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0006);
        wpsielen += 2;

        wf_memcpy(wpsie + wpsielen, "9192CU", 6);
        wpsielen += 6;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_MODEL_NUMBER);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0001);
        wpsielen += 2;

        wpsie[wpsielen++] = 0x31;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_SERIAL_NUMBER);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WF_ETH_ALEN);
        wpsielen += 2;

        wf_memcpy(wpsie + wpsielen, "123456", WF_ETH_ALEN);
        wpsielen += WF_ETH_ALEN;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0008);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
        wpsielen += 2;

        *(u32 *) (wpsie + wpsielen) = wf_cpu_to_be32(WPSOUI);
        wpsielen += 4;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_DEVICE_NAME);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(pwdinfo->device_name_len);
        wpsielen += 2;

        wf_memcpy(wpsie + wpsielen, pwdinfo->device_name,
                    pwdinfo->device_name_len);
        wpsielen += pwdinfo->device_name_len;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(WPS_ATTR_CONF_METHOD);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(0x0002);
        wpsielen += 2;

        *(u16 *) (wpsie + wpsielen) = wf_cpu_to_be16(pwdinfo->supported_wps_cm);
        wpsielen += 2;

        pframe =
            set_ie(pframe, WF_80211_MGMT_EID_VENDOR_SPECIFIC, wpsielen,
                       (unsigned char *)wpsie, &pattrib->pktlen);

        p2pielen = probe_resp_p2p_ie_build_func(pwdinfo, pframe, 1);
        pframe += p2pielen;
        pattrib->pktlen += p2pielen;
    }

#ifdef CONFIG_WFD
    wfdielen = probe_resp_wfd_ie_to_append_func(nic_info, pframe, 1);
    pframe += wfdielen;
    pattrib->pktlen += wfdielen;
#endif

    pattrib->last_txcmdsz = pattrib->pktlen;

    mgntframe_to_dump_func(nic_info, pmgntframe);

    return;
    */

}


static wf_u32 proc_p2p_listen_state_func(nic_info_st *pnic_info, unsigned char *da, wf_u8 flag)
{

    p2p_info_st *p2p_info = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &(p2p_info->wdinfo);
    
    wf_bool response = wf_true;

    if (pwdinfo->driver_interface == DRIVER_CFG80211) 
    {
       if (pwdinfo->is_ro_ch == wf_false || p2p_info->p2p_enabled == wf_false) 
       {
            response = wf_false;
       }
    } 
    else
    if (pwdinfo->driver_interface == DRIVER_WEXT) 
    {
        if (!pwdinfo->device_name_len) 
        {
            response = wf_false;
        }
    }
    P2P_FRAME_INFO("response=%d",response);

    if (flag && response == wf_true) 
    {
        probersp_p2p_to_issue_func(pnic_info, da, 1);
    }
    return 0;
}


static wf_u8 proc_p2p_probqeq_func(nic_info_st *pnic_info,wf_80211_mgmt_t *pframe, wf_u16 frame_len,
                         wf_u8 flag)
{
    p2p_info_st *p2p_info = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &(p2p_info->wdinfo);
    wf_u8 *probereq_ie = pframe->probe_req.variable;

    wf_s8 is_valid_p2p_probereq = 0;

    is_valid_p2p_probereq = probe_req_p2p_ie_process_func(pwdinfo, probereq_ie, frame_len, 1);
    if(is_valid_p2p_probereq == 0)
    {
        P2P_FRAME_DBG("[%d] p2p_role=%s",pnic_info->ndev_id,p2p_role_to_str(pwdinfo->role ));
        if(pwdinfo->role == P2P_ROLE_DEVICE)
        {
            //if(pwdinfo->driver_interface == DRIVER_WEXT)
            //realize wext later
            //survey_event_to_report_func(nic_info, precv_frame, 1);

            if(flag)
            {
               proc_p2p_listen_state_func(pnic_info, pframe->sa, 1);
            }

            return 0;
        }
        else if (P2P_ROLE_GO == pwdinfo->role)
        {
            return -1;
        }
    }
    else
    {
        P2P_FRAME_DBG("[%d] is_valid_p2p_probereq:%d",pnic_info->ndev_id, is_valid_p2p_probereq);
    }



    return -1;
}


wf_s32 wf_p2p_probereq_process(nic_info_st *pnic_info,wf_80211_mgmt_t *pframe, wf_u16 frame_len)
{
    wf_wlan_mgmt_info_t *pwlan_info = pnic_info->wlan_mgmt_info;
    p2p_info_st *p2p_info = pnic_info->p2p;
    wf_widev_priv_t *pwdev = NULL;
    p2p_wd_info_st *pwdinfo = &(p2p_info->wdinfo);

    pwdev = &pnic_info->widev_priv;
    if (!pnic_info->is_up)
    {
        return -1;
    }

    if (!(mac_addr_equal(pframe->da, pwlan_info->cur_network.mac_addr) || is_bcast_addr(pframe->da)))
    {
        P2P_FRAME_INFO("probe request target address invalid");
        return -3;
    }
#ifdef CONFIG_IOCTL_CFG80211
    if((pwdinfo->driver_interface == DRIVER_CFG80211) && (pwdinfo->p2p_state != P2P_STATE_NONE)
        && wf_true == GET_CFG80211_REPORT_MGMT(pwdev,WF_80211_FRM_PROBE_REQ))
    {
        if(wf_true == p2p_info->scb.init_flag &&p2p_info->scb.rx_mgmt)
        {
            P2P_FRAME_INFO(" da addr    : "WF_MAC_FMT,WF_MAC_ARG(pframe->da));
            P2P_FRAME_INFO(" sa addr    : "WF_MAC_FMT,WF_MAC_ARG(pframe->sa));
            P2P_FRAME_INFO(" bssid addr : "WF_MAC_FMT,WF_MAC_ARG(pframe->bssid));
            return p2p_info->scb.rx_mgmt(pnic_info,pframe,frame_len);
        }
    }
#endif

    P2P_FRAME_INFO("p2p_state:%s,role:%s",p2p_state_to_str(pwdinfo->p2p_state),p2p_role_to_str(pwdinfo->role));
    if((pwdinfo->p2p_state != P2P_STATE_NONE) &&
       (pwdinfo->p2p_state != P2P_STATE_IDLE) &&
       (pwdinfo->role      != P2P_ROLE_CLIENT) &&
       (pwdinfo->p2p_state != P2P_STATE_SCAN) &&
       (pwdinfo->p2p_state != P2P_STATE_FIND_PHASE_SEARCH)
        ){
            //P2P_FRAME_INFO(" #################using driver framework#################");
            if(proc_p2p_probqeq_func(pnic_info, pframe, frame_len, 1) < 0)
            {
                P2P_FRAME_INFO("[%s]%d: proc_p2p_probqeq_func failed",__func__,__LINE__);
                return -4;
            }
        }

    return 0;
}

static wf_u8 *p2p_attr_ch_list_dump_func(wf_u8 * p2p_ie, wf_u32 p2p_ielen, wf_u8 * buf, wf_u32 buf_len,wf_u8 flag)
{
    wf_u32 attr_contentlen = 0;
    wf_u8 *pattr = NULL;
    wf_s32 w_sz = 0;
    wf_u8 ch_cnt = 0;
    wf_u8 ch_list[40];

    if ((pattr =p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL,&attr_contentlen)) != NULL) 
    {
        wf_s32 i, j;
        wf_u32 num_of_ch;
        wf_u8 *pattr_temp = pattr + 3;

        attr_contentlen -= 3;

        if (flag) 
        {
            wf_memset(ch_list, 0, 40);
        }
        while (attr_contentlen > 0) 
        {
            num_of_ch = *(pattr_temp + 1);

            for (i = 0; i < num_of_ch; i++) 
            {
                for (j = 0; j < ch_cnt; j++)
                {
                    if (ch_list[j] == *(pattr_temp + 2 + i))
                    {
                        break;
                    }
                }
                if (j >= ch_cnt)
                {
                    ch_list[ch_cnt++] = *(pattr_temp + 2 + i);
                }

            }

            pattr_temp += (2 + num_of_ch);
            attr_contentlen -= (2 + num_of_ch);
        }

        for (j = 0; j < ch_cnt; j++) 
        {
            if (j == 0) 
            {
                w_sz += snprintf(buf + w_sz, buf_len - w_sz, "%u", ch_list[j]);
            } 
            else if (ch_list[j] - ch_list[j - 1] != 1) 
            {
                w_sz += snprintf(buf + w_sz, buf_len - w_sz, ", %u", ch_list[j]);
            } 
            else if (j != ch_cnt - 1 && ch_list[j + 1] - ch_list[j] == 1) 
            {
            } 
            else 
            {
                w_sz += snprintf(buf + w_sz, buf_len - w_sz, "-%u", ch_list[j]);
            }
        }
    }
    return buf;
}

static wf_bool p2p_nego_intent_to_compare_func(wf_u8 req, wf_u8 resp, wf_u8 flag)
{
    if (flag) 
    {
        if (req >> 1 == resp >> 1)
        {      
            return req & 0x01 ? wf_true : wf_false;
        }
        else if (req >> 1 > resp >> 1)
        {      
            return wf_true;
        }
        else
        {      
            return wf_false;
        }
    } 
    
    return wf_false;
}

#ifdef CONFIG_CONCURRENT_MODE
static bool p2pie_ch_list_with_buddy_to_chk_func(nic_info_st *pnic_info,wf_u8 * frame_body, wf_u32 len, wf_u8 flag)
{
    bool fit = wf_false;
    wf_u8 *ies, *p2p_ie;
    wf_u32 ies_len, p2p_ielen;
    wf_u8 buddy_ch = wf_p2p_get_buddy_channel(pnic_info);

    ies = (wf_u8 *) (frame_body + _PUBLIC_ACTION_IE_OFFSET_);
    ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;

    p2p_ie = p2p_ie_to_get_func(ies, ies_len, NULL, &p2p_ielen);

    if (flag) {
        while (p2p_ie) {
            u32 attr_contentlen = 0;
            u8 *pattr = NULL;

            if ((pattr = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST,NULL, (wf_u32 *) & attr_contentlen)) !=
                NULL) 
            {
                wf_s32 i;
                wf_u32 num_of_ch;
                wf_u8 *pattr_temp = pattr + 3;

                attr_contentlen -= 3;

                while (attr_contentlen > 0) 
                {
                    num_of_ch = *(pattr_temp + 1);

                    for (i = 0; i < num_of_ch; i++) 
                    {
                        if (*(pattr_temp + 2 + i) == buddy_ch) 
                        {
                            P2P_FRAME_INFO(" ch_list fit buddy_ch:%u\n", buddy_ch);
                            fit = wf_true;
                            break;
                        }
                    }

                    pattr_temp += (2 + num_of_ch);
                    attr_contentlen -= (2 + num_of_ch);
                }
            }

            p2p_ie =
                p2p_ie_to_get_func(p2p_ie + p2p_ielen,
                               ies_len - (p2p_ie - ies + p2p_ielen), NULL,
                               &p2p_ielen);
        }
    }
    return fit;
}

static void adjust_cfg80211_p2pie_channel_func(nic_info_st *pnic_info, wf_u8 * frame_body, wf_u32 len, wf_u8 flag)
{
    wf_u8 *ies, *p2p_ie;
    wf_u32 ies_len, p2p_ielen;

    ies = (wf_u8 *) (frame_body + _PUBLIC_ACTION_IE_OFFSET_);
    ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;

    p2p_ie = p2p_ie_to_get_func(ies, ies_len, NULL, &p2p_ielen);

    if (flag) 
    {
        while (p2p_ie) 
        {
            wf_u32 attr_contentlen = 0;
            wf_u8 *pattr = NULL;

            if ((pattr = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST,NULL,(wf_u32 *) & attr_contentlen)) !=
                NULL) 
            {
                wf_s32 i;
                wf_u32 num_of_ch;
                wf_u8 *pattr_temp = pattr + 3;

                attr_contentlen -= 3;

                while (attr_contentlen > 0) 
               {
                    num_of_ch = *(pattr_temp + 1);

                    for (i = 0; i < num_of_ch; i++)
                    {
                        *(pattr_temp + 2 + i) = wf_p2p_get_buddy_channel(pnic_info);
                    }

                    pattr_temp += (2 + num_of_ch);
                    attr_contentlen -= (2 + num_of_ch);
                }
            }

            attr_contentlen = 0;
            pattr = NULL;
            if ((pattr = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL,(wf_u32 *) & attr_contentlen)) !=
                NULL) 
            {
                *(pattr + 4) = wf_p2p_get_buddy_channel(pnic_info);
            }

            p2p_ie = p2p_ie_to_get_func(p2p_ie + p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);

        }
    }
}

static void p2pie_ch_list_to_change_func(nic_info_st *pnic_info, wf_u8 * frame_body,wf_u32 len, wf_u8 ch, wf_u8 flag)
{
    wf_u8 *ies, *p2p_ie;
    wf_u32 ies_len, p2p_ielen;
    ies = (wf_u8 *) (frame_body + _PUBLIC_ACTION_IE_OFFSET_);
    ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;

    p2p_ie = p2p_ie_to_get_func(ies, ies_len, NULL, &p2p_ielen);

    if (flag) 
    {
        while (p2p_ie) 
        {
            wf_u32 attr_contentlen = 0;
            wf_u8 *pattr = NULL;

            if ((pattr = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST,
                                          NULL,
                                          (wf_u32 *) & attr_contentlen)) !=
                NULL) {
                int i;
                wf_u32 num_of_ch;
                wf_u8 *pattr_temp = pattr + 3;

                attr_contentlen -= 3;

                while (attr_contentlen > 0) {
                    num_of_ch = *(pattr_temp + 1);

                    for (i = 0; i < num_of_ch; i++)
                        *(pattr_temp + 2 + i) = ch;

                    pattr_temp += (2 + num_of_ch);
                    attr_contentlen -= (2 + num_of_ch);
                }
            }

            p2p_ie = p2p_ie_to_get_func(p2p_ie + p2p_ielen,
                               ies_len - (p2p_ie - ies + p2p_ielen), NULL,
                               &p2p_ielen);
        }
    }
}

static bool p2pie_op_ch_with_buddy_to_chk_func(nic_info_st *pnic_info, wf_u8 * frame_body, wf_u32 len,wf_u8 flag)
{
    bool fit = wf_false;

    wf_u8 *ies, *p2p_ie;
    wf_u32 ies_len, p2p_ielen;
    wf_u8 buddy_ch = wf_p2p_get_buddy_channel(pnic_info);

    ies = (wf_u8 *) (frame_body + _PUBLIC_ACTION_IE_OFFSET_);
    ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;

    p2p_ie = p2p_ie_to_get_func(ies, ies_len, NULL, &p2p_ielen);

    if (flag) {
        while (p2p_ie) {
            wf_u32 attr_contentlen = 0;
            wf_u8 *pattr = NULL;

            attr_contentlen = 0;
            pattr = NULL;
            if ((pattr = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,
                                          P2P_ATTR_OPERATING_CH, NULL, (wf_u32 *) & attr_contentlen)) !=
                NULL) 
            {
                if (*(pattr + 4) == buddy_ch) 
                {
                    P2P_FRAME_INFO(" op_ch fit buddy_ch:%u\n", buddy_ch);
                    fit = wf_true;
                    break;
                }
            }

            p2p_ie =
                p2p_ie_to_get_func(p2p_ie + p2p_ielen,
                               ies_len - (p2p_ie - ies + p2p_ielen), NULL,
                               &p2p_ielen);
        }
    }

    return fit;
}
#endif

wf_s32 p2p_frames_to_check_func(nic_info_st *pnic_info, const wf_u8 * buf, wf_u32 len, wf_u8 tx,wf_u8 flag)
{
    wf_s32 is_p2p_frame = (-1);
    wf_u8 *frame_body   = NULL;
    wf_u8 category, action, OUI_Subtype, dialogToken = 0;
    wf_u8 *p2p_ie = NULL;
    wf_u32 p2p_ielen = 0;
    struct wf_widev_priv *pwdev_priv = &pnic_info->widev_priv;
    wf_s32 status = -1;
    wf_u8 ch_list_buf[128] = { '\0' };
    wf_s32 op_ch = -1;
    wf_s32 listen_ch = -1;
    wf_u8 intent = 0;
    p2p_info_st *p2p_info = NULL;

    if(NULL == pnic_info || NULL== buf)
    {
        LOG_E("[%s,%d] input param is null",__func__,__LINE__);
        return WF_RETURN_FAIL;
    }
    
    p2p_info = pnic_info->p2p;
    
    frame_body =(unsigned char *)(buf + sizeof(struct wl_ieee80211_hdr_3addr));
    category = frame_body[0];
    if (category == WF_WLAN_CATEGORY_PUBLIC) 
    {
        P2P_FRAME_DBG("[%d] WF_WLAN_CATEGORY_PUBLIC",pnic_info->ndev_id);
        action = frame_body[1];
        if (action == WF_WLAN_ACTION_PUBLIC_VENDOR && wf_memcmp(frame_body + 2, P2P_OUI, 4) == 0) 
        {
            OUI_Subtype = frame_body[6];
            dialogToken = frame_body[7];
            is_p2p_frame = OUI_Subtype;
            P2P_FRAME_DBG("[%d] ACTION_CATEGORY_PUBLIC: ACT_PUBLIC_VENDOR, OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
                 pnic_info->ndev_id,wf_cpu_to_be32(*((wf_u32 *) (frame_body + 2))), OUI_Subtype, dialogToken);

            p2p_ie = p2p_ie_to_get_func((wf_u8 *) buf +sizeof(struct wl_ieee80211_hdr_3addr) + WF_PUBLIC_ACTION_IE_OFFSET,
                                    len - sizeof(struct wl_ieee80211_hdr_3addr) - WF_PUBLIC_ACTION_IE_OFFSET, 
                                    NULL,
                                    &p2p_ielen);

            switch (OUI_Subtype) 
            {
                wf_u8 *cont;
                wf_u32 cont_len;
                case P2P_GO_NEGO_REQ:
                {
                    wf_widev_nego_info_t *nego_info = &pwdev_priv->nego_info;
                    P2P_FRAME_DBG("[%d] P2P_GO_NEGO_REQ",pnic_info->ndev_id);
                    if (tx) 
                    {
#ifdef CONFIG_DRV_ISSUE_PROV_REQ
                        if (pwdev_priv->provdisc_req_issued == wf_false)
                        {
                            Func_Of_Proc_Cfg_Nl_Issue_P2P_Provision_Request(pnic_info, buf, len);
                        }
#endif

#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
                        if (wf_p2p_check_buddy_linkstate(pnic_info) &&
                            p2p_info->full_ch_in_p2p_handshake == 0)
                            adjust_cfg80211_p2pie_channel_func(pnic_info,
                                                              frame_body,
                                                              len - sizeof(struct wl_ieee80211_hdr_3addr),
                                                              1);
#endif
                    }

                    if ((cont =p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_OPERATING_CH, NULL,&cont_len)))
                    {
                        op_ch = *(cont + 4);
                    }
                    if ((cont =p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_LISTEN_CH, NULL,&cont_len)))
                    {
                        listen_ch = *(cont + 4);
                    }
                    if ((cont =p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_GO_INTENT, NULL,&cont_len)))
                    {
                        intent = *cont;
                    }

                    if (nego_info->token != dialogToken)
                    {
                        wf_widev_nego_info_init(nego_info);
                    }

                    wf_memcpy(nego_info->peer_mac, tx ? GetAddr1Ptr(buf) : GetAddr2Ptr(buf), WF_ETH_ALEN);
                    nego_info->active           = tx ? 1 : 0;
                    nego_info->token            = dialogToken;
                    nego_info->req_op_ch        = op_ch;
                    nego_info->req_listen_ch    = listen_ch;
                    nego_info->req_intent       = intent;
                    nego_info->state            = 0;

                    p2p_attr_ch_list_dump_func(p2p_ie, p2p_ielen, ch_list_buf, 128,1);
                    
                    P2P_FRAME_INFO("%s:P2P_GO_NEGO_REQ, dialogToken=%d, intent:%u%s, listen_ch:%d, op_ch:%d, ch_list:%s, full_ch_in_p2p_handshake:%d\n",
                         (tx == wf_true) ? "Tx" : "Rx", dialogToken,
                         (intent >> 1), intent & 0x1 ? "+" : "-", listen_ch,
                         op_ch, ch_list_buf,p2p_info->full_ch_in_p2p_handshake);

                    if (!tx) 
                    {
#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
                        if (wf_p2p_check_buddy_linkstate(pnic_info)
                            && p2pie_ch_list_with_buddy_to_chk_func(pnic_info,
                                                                frame_body,
                                                                len -sizeof(struct wl_ieee80211_hdr_3addr),
                                                                1) == wf_false
                            && p2p_info->full_ch_in_p2p_handshake == 0) 
                        {
                            P2P_FRAME_INFO(" ch_list has no intersect with buddy\n");
                            p2pie_ch_list_to_change_func(pnic_info, frame_body,
                                                     len -sizeof(struct wl_ieee80211_hdr_3addr),
                                                     0, 1);
                        }
#endif
                    }

                    break;
                }
            case P2P_GO_NEGO_RESP:
                {
                    wf_widev_nego_info_t *nego_info = &pwdev_priv->nego_info;
                    P2P_FRAME_DBG("[%d] P2P_GO_NEGO_RESP",pnic_info->ndev_id);
                    if (tx) {
#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
                        if (wf_p2p_check_buddy_linkstate(pnic_info)
                            && p2p_info->full_ch_in_p2p_handshake == 0)
                        {
                            adjust_cfg80211_p2pie_channel_func(pnic_info,
                                                          frame_body,
                                                          len - sizeof(struct  wl_ieee80211_hdr_3addr),
                                                          1);
                        }
#endif
                    }

                    if ((cont =p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_OPERATING_CH, NULL,&cont_len)))
                        op_ch = *(cont + 4);
                    if ((cont =p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_GO_INTENT, NULL,&cont_len)))
                        intent = *cont;
                    if ((cont =p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_STATUS, NULL,&cont_len)))
                        status = *cont;

                    if (nego_info->token == dialogToken && nego_info->state == 0
                        && wf_memcmp(nego_info->peer_mac,tx ? GetAddr1Ptr(buf) : GetAddr2Ptr(buf),WF_ETH_ALEN) == 0) 
                    {
                        nego_info->status = (status == -1) ? 0xff : status;
                        nego_info->rsp_op_ch = op_ch;
                        nego_info->rsp_intent = intent;
                        nego_info->state = 1;
                        if (status != 0)
                        {
                            nego_info->token = 0;
                        }
                    }

                    p2p_attr_ch_list_dump_func(p2p_ie, p2p_ielen, ch_list_buf, 128,1);
                    P2P_FRAME_INFO("WL_%s:P2P_GO_NEGO_RESP, dialogToken=%d, intent:%u%s, status:%d, op_ch:%d, ch_list:%s\n",
                         (tx == wf_true) ? "Tx" : "Rx", dialogToken,
                         (intent >> 1), intent & 0x1 ? "+" : "-", status, op_ch,
                         ch_list_buf);

                    if (!tx) 
                    {
                        pwdev_priv->provdisc_req_issued = wf_false;
#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
                        if (wf_p2p_check_buddy_linkstate(pnic_info)
                            && p2pie_ch_list_with_buddy_to_chk_func(pnic_info,
                                                                frame_body,
                                                                len - sizeof(struct wl_ieee80211_hdr_3addr),
                                                                1) == wf_false
                            && p2p_info->full_ch_in_p2p_handshake == 0) 
                       {
                            P2P_FRAME_INFO( " ch_list has no intersect with buddy\n");
                            p2pie_ch_list_to_change_func(pnic_info, frame_body,
                                                     len - sizeof(struct wl_ieee80211_hdr_3addr),
                                                     0, 1);
                        }
#endif
                    }

                    break;
                }
            case P2P_GO_NEGO_CONF:
                {
                    wf_widev_nego_info_t *nego_info =&pwdev_priv->nego_info;
                    wf_bool is_go = wf_false;
                    P2P_FRAME_DBG("[%d] P2P_GO_NEGO_CONF",pnic_info->ndev_id);
                    if (tx) 
                    {
#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
                        if (wf_p2p_check_buddy_linkstate(pnic_info) && p2p_info->full_ch_in_p2p_handshake == 0)
                            adjust_cfg80211_p2pie_channel_func(pnic_info, frame_body,
                                                              len - sizeof(struct wl_ieee80211_hdr_3addr),
                                                              1);
#endif
                    }

                    if ((cont = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_OPERATING_CH, NULL, &cont_len)))
                    {
                        op_ch = *(cont + 4);
                    }
                    if ((cont = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_STATUS, NULL,&cont_len)))
                    {
                        status = *cont;
                    }

                    if (nego_info->token == dialogToken && nego_info->state == 1 && 
                        wf_memcmp(nego_info->peer_mac,tx ? GetAddr1Ptr(buf) : GetAddr2Ptr(buf),WF_ETH_ALEN) == 0) 
                    {
                        nego_info->status = (status == -1) ? 0xff : status;
                        nego_info->conf_op_ch = (op_ch == -1) ? 0 : op_ch;
                        nego_info->state = 2;

                        if (status == 0) 
                        {
                            if (p2p_nego_intent_to_compare_func(nego_info->req_intent, nego_info->rsp_intent,1) ^ !tx)
                            {
                                is_go = wf_true;
                            }
                        }

                        nego_info->token = 0;
                    }

                    p2p_attr_ch_list_dump_func(p2p_ie, p2p_ielen, ch_list_buf, 128, 1);
                    P2P_FRAME_INFO("WL_%s:P2P_GO_NEGO_CONF, dialogToken=%d, status:%d, op_ch:%d, ch_list:%s\n",
                         (tx == wf_true) ? "Tx" : "Rx", dialogToken, status,op_ch, ch_list_buf);

                    if (!tx) 
                    {
                    }

                    break;
                }
            case P2P_INVIT_REQ:
                {
                    struct wf_widev_invit_info *invit_info = &pwdev_priv->invit_info;
                    wf_s32 flags = -1;
                    P2P_FRAME_DBG("[%d] P2P_INVIT_REQ",pnic_info->ndev_id);
                    if (tx) {
#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
                        if (wf_p2p_check_buddy_linkstate(pnic_info)  && p2p_info->full_ch_in_p2p_handshake == 0)
                            adjust_cfg80211_p2pie_channel_func(pnic_info,
                                                              frame_body,
                                                              len -
                                                              sizeof(struct
                                                                     wl_ieee80211_hdr_3addr),
                                                              1);
#endif
                    }

                    if ((cont =
                         p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,
                                                  P2P_ATTR_INVITATION_FLAGS,
                                                  NULL, &cont_len)))
                        flags = *cont;
                    if ((cont = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,
                                                  P2P_ATTR_OPERATING_CH, NULL,&cont_len)))
                        op_ch = *(cont + 4);

                    if (invit_info->token != dialogToken)
                    {
                        wf_widev_invit_info_init(invit_info);
                    }

                    wf_memcpy(invit_info->peer_mac,tx ? GetAddr1Ptr(buf) : GetAddr2Ptr(buf),WF_ETH_ALEN);
                    invit_info->active = tx ? 1 : 0;
                    invit_info->token = dialogToken;
                    invit_info->flags = (flags == -1) ? 0x0 : flags;
                    invit_info->req_op_ch = op_ch;
                    invit_info->state = 0;

                    p2p_attr_ch_list_dump_func(p2p_ie, p2p_ielen, ch_list_buf, 128,
                                          1);
                    P2P_FRAME_INFO
                        ("WL_%s:P2P_INVIT_REQ, dialogToken=%d, flags:0x%02x, op_ch:%d, ch_list:%s\n",
                         (tx == wf_true) ? "Tx" : "Rx", dialogToken, flags, op_ch,
                         ch_list_buf);

                    if (!tx) {
#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
                        if (wf_p2p_check_buddy_linkstate(pnic_info) && p2p_info->full_ch_in_p2p_handshake == 0) 
                        {
                            if (op_ch != -1 && p2pie_op_ch_with_buddy_to_chk_func(pnic_info,
                                                                  frame_body,
                                                                  len - sizeof(struct wl_ieee80211_hdr_3addr),
                                                                  1) == wf_false) 
                           {
                                P2P_FRAME_INFO( " op_ch:%u has no intersect with buddy\n", op_ch);
                                p2pie_ch_list_to_change_func(pnic_info, frame_body,
                                                          len -sizeof(struct wl_ieee80211_hdr_3addr),
                                                         0, 1);
                            } else if (p2pie_ch_list_with_buddy_to_chk_func
                                    (pnic_info, frame_body,
                                     len -sizeof(struct wl_ieee80211_hdr_3addr),
                                     1) == wf_false) 
                           {
                                P2P_FRAME_INFO(" ch_list has no intersect with buddy\n");
                                p2pie_ch_list_to_change_func(pnic_info, frame_body,
                                                         len -sizeof(struct wl_ieee80211_hdr_3addr),
                                                         0, 1);
                            }
                        }
#endif
                    }

                    break;
                }
            case P2P_INVIT_RESP:
                {
                    wf_widev_invit_info_t *invit_info =&pwdev_priv->invit_info;
                    P2P_FRAME_DBG("[%d] P2P_INVIT_RESP",pnic_info->ndev_id);
                    if (tx) 
                    {
#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT)
                        if (wf_p2p_check_buddy_linkstate(pnic_info)
                            && p2p_info->full_ch_in_p2p_handshake == 0)
                            adjust_cfg80211_p2pie_channel_func(pnic_info,
                                                              frame_body,
                                                              len -sizeof(struct wl_ieee80211_hdr_3addr),
                                                              1);
#endif
                    }

                    if ((cont = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_STATUS, NULL,&cont_len))) 
                    {
#ifdef CONFIG_P2P_INVITE_IOT
                        if (tx && *cont == 7) 
                       {
                            P2P_FRAME_INFO("TX_P2P_INVITE_RESP, status is no common channel, change to unknown group\n");
                            *cont = 8;
                        }
#endif
                        status = *cont;
                    }
                    if ((cont = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,P2P_ATTR_OPERATING_CH, NULL,&cont_len)))
                    {
                        op_ch = *(cont + 4);
                    }

                    if (invit_info->token == dialogToken
                        && invit_info->state == 0
                        && wf_memcmp(invit_info->peer_mac,tx ? GetAddr1Ptr(buf) : GetAddr2Ptr(buf), WF_ETH_ALEN) == 0) 
                    {
                        invit_info->status = (status == -1) ? 0xff : status;
                        invit_info->rsp_op_ch = op_ch;
                        invit_info->state = 1;
                        invit_info->token = 0;
                    }

                    p2p_attr_ch_list_dump_func(p2p_ie, p2p_ielen, ch_list_buf, 128,1);
                    P2P_FRAME_INFO("WF_%s:P2P_INVIT_RESP, dialogToken=%d, status:%d, op_ch:%d, ch_list:%s\n",
                         (tx == wf_true) ? "Tx" : "Rx", dialogToken, status,
                         op_ch, ch_list_buf);

                    if (!tx) 
                    {
                    }

                    break;
                }
            case P2P_DEVDISC_REQ:
                P2P_FRAME_INFO("WF_%s:P2P_DEVDISC_REQ, dialogToken=%d\n",(tx == wf_true) ? "Tx" : "Rx", dialogToken);
                break;
            case P2P_DEVDISC_RESP:
                cont = p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_STATUS,NULL, &cont_len);
                P2P_FRAME_INFO("WF_%s:P2P_DEVDISC_RESP, dialogToken=%d, status:%d\n",(tx == wf_true) ? "Tx" : "Rx", dialogToken,cont ? *cont : -1);
                break;
            case P2P_PROVISION_DISC_REQ:
                {
                    wf_u32 frame_body_len =len - sizeof(struct wl_ieee80211_hdr_3addr);
                    wf_u8 *p2p_ie;
                    wf_u32 p2p_ielen = 0;
                    wf_u32 contentlen = 0;

                    P2P_FRAME_INFO("WF_%s:P2P_PROVISION_DISC_REQ, dialogToken=%d\n",(tx == wf_true) ? "Tx" : "Rx", dialogToken);

                    pwdev_priv->provdisc_req_issued = wf_false;
                    if ((p2p_ie =p2p_ie_to_get_func(frame_body + WF_PUBLIC_ACTION_IE_OFFSET,frame_body_len - WF_PUBLIC_ACTION_IE_OFFSET, NULL, &p2p_ielen))) 
                    {

                        if (p2p_attr_content_to_get_func (p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen)) 
                        {
                            pwdev_priv->provdisc_req_issued = wf_false;
                        } 
                        else 
                        {
                            P2P_FRAME_INFO("provdisc_req_issued is wf_true\n");
                            pwdev_priv->provdisc_req_issued = wf_true;
                        }

                    }

                }
                break;
            case P2P_PROVISION_DISC_RESP:
                P2P_FRAME_INFO("WF_%s:P2P_PROVISION_DISC_RESP, dialogToken=%d\n",(tx == wf_true) ? "Tx" : "Rx", dialogToken);
                break;
            default:
                P2P_FRAME_INFO("WF_%s:OUI_Subtype=%d, dialogToken=%d\n",(tx == wf_true) ? "Tx" : "Rx", OUI_Subtype, dialogToken);
                break;
            }

        }

    } 
    else if (category == WF_WLAN_CATEGORY_P2P) 
    {
        OUI_Subtype = frame_body[5];
        dialogToken = frame_body[6];

        P2P_FRAME_DBG("[%d] ACTION_CATEGORY_P2P: OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
             pnic_info->ndev_id,wf_cpu_to_be32(*((wf_u32 *) (frame_body + 1))), OUI_Subtype, dialogToken);

        is_p2p_frame = OUI_Subtype;

        if (flag) 
        {
            switch (OUI_Subtype) 
            {
            case P2P_NOTICE_OF_ABSENCE:
                P2P_FRAME_INFO("WF_%s:P2P_NOTICE_OF_ABSENCE, dialogToken=%d\n",(tx == wf_true) ? "TX" : "RX", dialogToken);
                break;
            case P2P_PRESENCE_REQUEST:
                P2P_FRAME_INFO("WF_%s:P2P_PRESENCE_REQUEST, dialogToken=%d\n",(tx == wf_true) ? "TX" : "RX", dialogToken);
                break;
            case P2P_PRESENCE_RESPONSE:
                P2P_FRAME_INFO("WF_%s:P2P_PRESENCE_RESPONSE, dialogToken=%d\n",(tx == wf_true) ? "TX" : "RX", dialogToken);
                break;
            case P2P_GO_DISC_REQUEST:
                P2P_FRAME_INFO("WF_%s:P2P_GO_DISC_REQUEST, dialogToken=%d\n", (tx == wf_true) ? "TX" : "RX", dialogToken);
                break;
            default:
                P2P_FRAME_INFO("WF_%s:OUI_Subtype=%d, dialogToken=%d\n", (tx == wf_true) ? "TX" : "RX", OUI_Subtype, dialogToken);
                break;
            }
        }

    } 
    else 
    {
        P2P_FRAME_INFO("WF_%s:action frame category=%d\n",(tx == wf_true) ? "TX" : "RX", category);
    }

    return is_p2p_frame;
}

static wf_u8 p2p_peer_ch_list_to_get_func(p2p_wd_info_st * pwdinfo, wf_u8 * ch_content,wf_u8 ch_cnt, wf_u8 * peer_ch_list, wf_u8 flag)
{
    wf_u8 i = 0, j = 0;
    wf_u8 temp = 0;
    wf_u8 ch_no = 0;
    
    ch_content += 3;
    ch_cnt -= 3;

    if (flag) 
    {
        while (ch_cnt > 0) 
        {
            ch_content += 1;
            ch_cnt -= 1;
            temp = *ch_content;
            for (i = 0; i < temp; i++, j++) 
            {
                peer_ch_list[j] = *(ch_content + 1 + i);
            }
            ch_content += (temp + 1);
            ch_cnt -= (temp + 1);
            ch_no += temp;
        }
    }
    return ch_no;
}

static wf_u8 inclusion_of_p2p_ch_func(hw_info_st *hw_info, wf_u8 * peer_ch_list,wf_u8 peer_ch_num, wf_u8 * ch_list_inclusioned, wf_u8 flag)
{
    wf_s32 i = 0, j = 0, temp = 0;
    wf_u8 ch_no = 0;

    if (flag) {
        for (i = 0; i < peer_ch_num; i++) {
            for (j = temp; j < hw_info->max_chan_nums; j++) {
                if (*(peer_ch_list + i) == hw_info->channel_set[j].channel_num) 
                {
                    ch_list_inclusioned[ch_no++] = *(peer_ch_list + i);
                    temp = j;
                    break;
                }
            }
        }
    }

    return ch_no;
}


static int check_p2p_is_channel_list_ok_func(wf_u8 desired_ch, wf_u8 * ch_list, wf_u8 ch_cnt, wf_u8 flag)
{
    int found = 0, i = 0;

    if (flag) 
    {
        for (i = 0; i < ch_cnt; i++) 
        {
            if (ch_list[i] == desired_ch) 
            {
                found = 1;
                break;
            }
        }
    }
    return (found);
}

wf_u8 p2p_group_negotation_req_process_func(nic_info_st *pnic_info,wf_u8 * pframe, wf_u32 len, wf_u8 flag)
{
    wf_u8 result = P2P_STATUS_SUCCESS;
    wf_u32 p2p_ielen = 0, wps_ielen = 0;
    wf_u8 *ies;
    wf_u32 ies_len;
    wf_u8 *p2p_ie;
    wf_u8 *wpsie;
    wf_u16 wps_devicepassword_id = 0x0000;
    wf_u32 wps_devicepassword_id_len = 0;
    p2p_info_st *p2p_info = pnic_info->p2p;
    p2p_wd_info_st * pwdinfo = &p2p_info->wdinfo;
#ifdef CONFIG_WFD
#endif
#ifdef CONFIG_CONCURRENT_MODE
    //nic_info_st *pbuddy_nic = pnic_info->vir_nic;
    //p2p_info_st *pbuddy_p2p_info = pbuddy_nic->p2p;
    //p2p_wd_info_st *pbuddy_wdinfo = &pbuddy_p2p_info->wdinfo;
#endif

    if ((wpsie = wf_wlan_get_wps_ie(pframe + WF_PUBLIC_ACTION_IE_OFFSET,len - WF_PUBLIC_ACTION_IE_OFFSET, NULL, &wps_ielen))) 
    {
        if (0 == wf_memcmp(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3)) 
        {
            wf_wlan_get_wps_attr_content(1, wpsie, wps_ielen, WPS_ATTR_DEVICE_PWID,(wf_u8 *) & wps_devicepassword_id,&wps_devicepassword_id_len);
            wps_devicepassword_id = wf_be16_to_cpu(wps_devicepassword_id);

            if (wps_devicepassword_id == WPS_DPID_USER_SPEC) 
            {
                wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
            } 
            else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC) 
            {
                wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3);
            } 
            else 
            {
                wf_memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3);
            }
        }
    }
   else 
   {
        P2P_FRAME_INFO("[%s] WPS IE not Found!!\n", __FUNCTION__);
        result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
        p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
        return (result);
    }

    ies = pframe + WF_PUBLIC_ACTION_IE_OFFSET;
    ies_len = len - WF_PUBLIC_ACTION_IE_OFFSET;

    p2p_ie = p2p_ie_to_get_func(ies, ies_len, NULL, &p2p_ielen);

    if (!p2p_ie) 
    {
        P2P_FRAME_INFO("[%s] P2P IE not Found!!\n", __FUNCTION__);
        result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
        if (flag) 
        {
            p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
        }
    }

    while (p2p_ie) 
    {
        wf_u8 attr_content = 0x00;
        wf_u32 attr_contentlen = 0;
        wf_u8 ch_content[100] = { 0x00 };
        wf_u32 ch_cnt = 0;
        wf_u8 peer_ch_list[100] = { 0x00 };
        wf_u8 peer_ch_num = 0;
        wf_u8 ch_list_inclusioned[100] = { 0x00 };
        wf_u8 ch_num_inclusioned = 0;
        wf_u16 cap_attr;
        wf_u8 listen_ch_attr[5] = { 0x00 };

        p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);

        if (p2p_attr_content_to_get_func
            (p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (wf_u8 *) & cap_attr,
             (wf_u32 *) & attr_contentlen)) 
        {
            cap_attr = wf_le16_to_cpu(cap_attr);
        }

        if (p2p_attr_content_to_get_func
            (p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT, &attr_content,
             &attr_contentlen)) {
            P2P_FRAME_INFO("[%s] GO Intent = %d, tie = %d\n", __FUNCTION__,
                    attr_content >> 1, attr_content & 0x01);
            pwdinfo->peer_intent = attr_content;

            if (pwdinfo->intent == (pwdinfo->peer_intent >> 1)) {
                if (pwdinfo->intent == P2P_MAX_INTENT) {
                    p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
                    result = P2P_STATUS_FAIL_BOTH_GOINTENT_15;
                } else {
                    if (attr_content & 0x01) {
                        p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
                    } else {
                        p2p_set_role(pwdinfo, P2P_ROLE_GO);
                    }
                }
            } else if (pwdinfo->intent > (pwdinfo->peer_intent >> 1)) 
            {
                p2p_set_role(pwdinfo, P2P_ROLE_GO);
            } 
            else 
            {
                p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
            }

            if (pwdinfo->role == P2P_ROLE_GO) 
            {
                wf_memcpy(pwdinfo->groupid_info.go_device_addr,
                            pwdinfo->device_addr, WF_ETH_ALEN);
                wf_memcpy(pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid,
                            pwdinfo->nego_ssidlen);
            }
        }

        if (p2p_attr_content_to_get_func
            (p2p_ie, p2p_ielen, P2P_ATTR_LISTEN_CH, (u8 *) listen_ch_attr,
             (wf_u32 *) & attr_contentlen) && attr_contentlen == 5)
            pwdinfo->nego_req_info.peer_ch = listen_ch_attr[4];

        P2P_FRAME_INFO(" listen channel :%u\n" ,pwdinfo->nego_req_info.peer_ch);

        attr_contentlen = 0;
        if (p2p_attr_content_to_get_func
            (p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR,
             pwdinfo->p2p_peer_interface_addr, &attr_contentlen)) 
        {
            if (attr_contentlen != WF_ETH_ALEN) {
                wf_memset(pwdinfo->p2p_peer_interface_addr, 0x00, WF_ETH_ALEN);
            }
        }

        if (p2p_attr_content_to_get_func
            (p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, ch_content, &ch_cnt)) 
        {
            peer_ch_num = p2p_peer_ch_list_to_get_func(pwdinfo, ch_content, ch_cnt,peer_ch_list, 1);
            ch_num_inclusioned =inclusion_of_p2p_ch_func(pnic_info->hw_info, peer_ch_list,peer_ch_num, ch_list_inclusioned, 1);

            if (ch_num_inclusioned == 0) 
            {
                P2P_FRAME_INFO("[%s] No common channel in channel list!\n",
                        __FUNCTION__);
                result = P2P_STATUS_FAIL_NO_COMMON_CH;
                p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
                break;
            }

            if (pwdinfo->role == P2P_ROLE_GO) 
            {
                if (!check_p2p_is_channel_list_ok_func(pwdinfo->operating_channel,ch_list_inclusioned, ch_num_inclusioned, 1)) 
                {
#ifdef CONFIG_CONCURRENT_MODE
                    if (wf_p2p_check_buddy_linkstate(pnic_info) && p2p_info->full_ch_in_p2p_handshake == 0) 
                    {
                        P2P_FRAME_INFO("[%s] desired channel NOT Found!\n", __FUNCTION__);
                        result = P2P_STATUS_FAIL_NO_COMMON_CH;
                        p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
                        break;
                    } else
#endif
                    {
                        wf_u8 operatingch_info[5] = { 0x00 };
                        wf_u8 peer_operating_ch = 0;
                        
                        attr_contentlen = 0;

                        if (p2p_attr_content_to_get_func
                            (p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH,
                             operatingch_info, &attr_contentlen)) {
                            peer_operating_ch = operatingch_info[4];
                        }

                        if (check_p2p_is_channel_list_ok_func(peer_operating_ch, ch_list_inclusioned, ch_num_inclusioned, 1)) 
                        {
                            pwdinfo->operating_channel = peer_operating_ch;
                            P2P_FRAME_INFO("[%s] Change op ch to %02x as peer's\n",
                                    __FUNCTION__, pwdinfo->operating_channel);
                        } else {
                            pwdinfo->operating_channel = ch_list_inclusioned[0];
                            P2P_FRAME_INFO("[%s] Change op ch to %02x\n", __FUNCTION__,
                                    pwdinfo->operating_channel);
                        }
                    }

                }
            }
        }

        p2p_ie = p2p_ie_to_get_func(p2p_ie + p2p_ielen,
                           ies_len - (p2p_ie - ies + p2p_ielen), NULL,
                           &p2p_ielen);
    }

    if (pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO) 
    {
        result = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
        p2p_set_state(pwdinfo, P2P_STATE_TX_INFOR_NOREADY);
        return result;
    }
#ifdef CONFIG_WFD
    //do_work_wfd_ies(pnic_info, __func__, pframe + WF_PUBLIC_ACTION_IE_OFFSET,len - WF_PUBLIC_ACTION_IE_OFFSET);
#endif

    return (result);
}



wf_u8 p2p_group_negotation_resp_process_func(nic_info_st *pnic_info,wf_u8 * pframe, wf_s32 len, wf_u8 flag)
{
    wf_u8 result = P2P_STATUS_SUCCESS;
    wf_u32 p2p_ielen, wps_ielen;
    wf_u8 *ies;
    wf_u32 ies_len;
    wf_u8 *p2p_ie;
    p2p_info_st *p2p_info = pnic_info->p2p;
    p2p_wd_info_st * pwdinfo = &p2p_info->wdinfo;

    ies = pframe + WF_PUBLIC_ACTION_IE_OFFSET;
    ies_len = len - WF_PUBLIC_ACTION_IE_OFFSET;

    if (wf_wlan_get_wps_ie(ies, ies_len, NULL, &wps_ielen)) 
    {

    }
    else 
    {
        P2P_FRAME_INFO("[%s] WPS IE not Found!!\n", __FUNCTION__);
        result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
        if (flag) {
            p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
        }
    }

    p2p_ie = p2p_ie_to_get_func(ies, ies_len, NULL, &p2p_ielen);
    if (!p2p_ie) {
        p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
        p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
        result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
    } else {

        wf_u8 attr_content = 0x00;
        wf_u32 attr_contentlen = 0;
        wf_u8 operatingch_info[5] = { 0x00 };
        //wf_u32 ch_cnt = 0;
        //wf_u8 ch_content[100] = { 0x00 };
        wf_u8 groupid[38];
        wf_u16 cap_attr;
        wf_u8 peer_ch_list[100] = { 0x00 };
        wf_u8 peer_ch_num = 0;
        wf_u8 ch_list_inclusioned[100] = { 0x00 };
        wf_u8 ch_num_inclusioned = 0;

        while (p2p_ie) {

            if (p2p_attr_content_to_get_func
                (p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (wf_u8 *) & cap_attr,
                 (wf_u32 *) & attr_contentlen)) {
                cap_attr = wf_le16_to_cpu(cap_attr);
            }

            p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_STATUS,
                                     &attr_content, &attr_contentlen);
            if (attr_contentlen == 1) {
                P2P_FRAME_INFO("[%s] Status = %d\n", __FUNCTION__, attr_content);
                if (attr_content == P2P_STATUS_SUCCESS) {
                } else {
                    if (P2P_STATUS_FAIL_INFO_UNAVAILABLE == attr_content) {
                        p2p_set_state(pwdinfo, P2P_STATE_RX_INFOR_NOREADY);
                    } else {
                        p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
                    }
                    p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
                    result = attr_content;
                    break;
                }
            }

            attr_contentlen = 0;
            if (p2p_attr_content_to_get_func
                (p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR,
                 pwdinfo->p2p_peer_interface_addr, &attr_contentlen)) {
                if (attr_contentlen != WF_ETH_ALEN) {
                    wf_memset(pwdinfo->p2p_peer_interface_addr, 0x00, WF_ETH_ALEN);
                }
            }

            attr_content = 0x00;
            attr_contentlen = 0;
            if (p2p_attr_content_to_get_func
                (p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT, &attr_content,
                 &attr_contentlen)) {
                P2P_FRAME_INFO("[%s] GO Intent = %d, tie = %d\n", __FUNCTION__,
                        attr_content >> 1, attr_content & 0x01);
                pwdinfo->peer_intent = attr_content;

                if (pwdinfo->intent == (pwdinfo->peer_intent >> 1)) {
                    if (pwdinfo->intent == P2P_MAX_INTENT) {
                        p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
                        result = P2P_STATUS_FAIL_BOTH_GOINTENT_15;
                        p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
                    } else {
                        p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
                        p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
                        if (attr_content & 0x01) {
                            p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
                        } else {
                            p2p_set_role(pwdinfo, P2P_ROLE_GO);
                        }
                    }
                } else if (pwdinfo->intent > (pwdinfo->peer_intent >> 1)) {
                    p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
                    p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
                    p2p_set_role(pwdinfo, P2P_ROLE_GO);
                } else {
                    p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
                    p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
                    p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
                }

                if (pwdinfo->role == P2P_ROLE_GO) 
                {
                    wf_memcpy(pwdinfo->groupid_info.go_device_addr,
                                pwdinfo->device_addr, WF_ETH_ALEN);
                    wf_memcpy(pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid,
                                pwdinfo->nego_ssidlen);

                }
            }

            attr_contentlen = 0;
            if (p2p_attr_content_to_get_func
                (p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info,
                 &attr_contentlen)) {
                P2P_FRAME_INFO("[%s] Peer's operating channel = %d\n", __FUNCTION__,
                        operatingch_info[4]);
                pwdinfo->peer_operating_ch = operatingch_info[4];
            }

            if (p2p_attr_content_to_get_func
                (p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST,
                 pwdinfo->channel_list_attr, &pwdinfo->channel_list_attr_len)) {
                P2P_FRAME_INFO("[%s] channel list attribute found, len = %d\n",
                        __FUNCTION__, pwdinfo->channel_list_attr_len);

                peer_ch_num =
                    p2p_peer_ch_list_to_get_func(pwdinfo,
                                             pwdinfo->channel_list_attr,
                                             pwdinfo->channel_list_attr_len,
                                             peer_ch_list, 1);
                ch_num_inclusioned = inclusion_of_p2p_ch_func(pnic_info->hw_info, peer_ch_list,
                                         peer_ch_num, ch_list_inclusioned, 1);

                if (ch_num_inclusioned == 0) {
                    P2P_FRAME_INFO("[%s] No common channel in channel list!\n",
                            __FUNCTION__);
                    result = P2P_STATUS_FAIL_NO_COMMON_CH;
                    p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
                    break;
                }

                if (pwdinfo->role == P2P_ROLE_GO) {
                    if (!check_p2p_is_channel_list_ok_func(pwdinfo->operating_channel,
                                                    ch_list_inclusioned,
                                                    ch_num_inclusioned, 1)) {
#ifdef CONFIG_CONCURRENT_MODE
                        if (wf_p2p_check_buddy_linkstate(pnic_info) && p2p_info->full_ch_in_p2p_handshake == 0) 
                        {
                            P2P_FRAME_INFO("[%s] desired channel NOT Found!\n",
                                    __FUNCTION__);
                            result = P2P_STATUS_FAIL_NO_COMMON_CH;
                            p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
                            break;
                        } else
#endif
                        {
                            wf_u8 operatingch_info[5] = { 0x00 };
                            wf_u8 peer_operating_ch = 0;
                            attr_contentlen = 0;

                            if (p2p_attr_content_to_get_func
                                (p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH,
                                 operatingch_info, &attr_contentlen)) {
                                peer_operating_ch = operatingch_info[4];
                            }

                            if (check_p2p_is_channel_list_ok_func(peer_operating_ch,
                                                           ch_list_inclusioned,
                                                           ch_num_inclusioned,
                                                           1)) {
                                pwdinfo->operating_channel = peer_operating_ch;
                                P2P_FRAME_INFO("[%s] Change op ch to %02x as peer's\n",
                                        __FUNCTION__,
                                        pwdinfo->operating_channel);
                            } else {
                                pwdinfo->operating_channel =
                                    ch_list_inclusioned[0];
                                P2P_FRAME_INFO("[%s] Change op ch to %02x\n",
                                        __FUNCTION__,
                                        pwdinfo->operating_channel);
                            }
                        }

                    }
                }

            } 
            else 
            {
                P2P_FRAME_INFO("[%s] channel list attribute not found!\n",
                        __FUNCTION__);
            }

            attr_contentlen = 0;
            wf_memset(groupid, 0x00, 38);
            if (p2p_attr_content_to_get_func
                (p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid,
                 &attr_contentlen)) {
                wf_memcpy(pwdinfo->groupid_info.go_device_addr, &groupid[0],
                            WF_ETH_ALEN);
                wf_memcpy(pwdinfo->groupid_info.ssid, &groupid[6],
                            attr_contentlen - WF_ETH_ALEN);
            }

            p2p_ie =
                p2p_ie_to_get_func(p2p_ie + p2p_ielen,
                               ies_len - (p2p_ie - ies + p2p_ielen), NULL,
                               &p2p_ielen);
        }

    }

#ifdef CONFIG_WFD
    //do_work_wfd_ies(pnic_info, __func__, pframe + WF_PUBLIC_ACTION_IE_OFFSET,len - WF_PUBLIC_ACTION_IE_OFFSET);
#endif

    return (result);

}

 
 wf_u8 p2p_group_negotation_confirm_process_func(nic_info_st *pnic_info,wf_u8 * pframe, wf_u32 len, wf_u8 flag)
 {
     wf_u8 *ies;
     wf_u32 ies_len;
     wf_u8 *p2p_ie;
     wf_u32 p2p_ielen = 0;
     wf_u8 result = P2P_STATUS_SUCCESS;
     p2p_info_st *p2p_info = pnic_info->p2p;
     p2p_wd_info_st * pwdinfo = &p2p_info->wdinfo;
     
     ies = pframe + WF_PUBLIC_ACTION_IE_OFFSET;
     ies_len = len - WF_PUBLIC_ACTION_IE_OFFSET;
 
     p2p_ie = p2p_ie_to_get_func(ies, ies_len, NULL, &p2p_ielen);
     if (flag) {
         while (p2p_ie) {
             wf_u8 attr_content = 0x00, operatingch_info[5] = { 0x00 };
             wf_u8 groupid[38] = { 0x00 };
             wf_u32 attr_contentlen = 0;
 
             pwdinfo->negotiation_dialog_token = 1;
             p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_STATUS,
                                      &attr_content, &attr_contentlen);
             if (attr_contentlen == 1) {
                 P2P_FRAME_INFO("[%s] Status = %d\n", __FUNCTION__, attr_content);
                 result = attr_content;
 
                 if (attr_content == P2P_STATUS_SUCCESS) 
                 {
                     wf_os_api_timer_unreg(&p2p_info->restore_p2p_state_timer);
 
                     p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
                     p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
                     if ((pwdinfo->intent) > (pwdinfo->peer_intent >> 1)) {
                         p2p_set_role(pwdinfo, P2P_ROLE_GO);
                     } else if ((pwdinfo->intent) < (pwdinfo->peer_intent >> 1)) {
                         p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
                     } else {
                         if (pwdinfo->peer_intent & 0x01) {
                             p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
                         } else {
                             p2p_set_role(pwdinfo, P2P_ROLE_GO);
                         }
                     }
 
#ifdef CONFIG_CONCURRENT_MODE
                     if (wf_p2p_check_buddy_linkstate(pnic_info) && p2p_info->full_ch_in_p2p_handshake == 0) 
                     {
                         wf_os_api_timer_set(&p2p_info->ap_p2p_switch_timer, 100);
                     }
#endif
                 } 
                 else 
                 {
                     p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
                     p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
                     break;
                 }
             }
 
             attr_contentlen = 0;
             wf_memset(groupid, 0x00, 38);
             if (p2p_attr_content_to_get_func
                 (p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid,
                  &attr_contentlen)) {
                 P2P_FRAME_INFO("[%s] Ssid = %s, ssidlen = %zu\n", __FUNCTION__,
                         &groupid[WF_ETH_ALEN], strlen(&groupid[WF_ETH_ALEN]));
                 wf_memcpy(pwdinfo->groupid_info.go_device_addr, &groupid[0],
                             WF_ETH_ALEN);
                 wf_memcpy(pwdinfo->groupid_info.ssid, &groupid[6],
                             attr_contentlen - WF_ETH_ALEN);
             }
 
             attr_contentlen = 0;
             if (p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info,
                  &attr_contentlen)) 
             {
                 P2P_FRAME_INFO("[%s] Peer's operating channel = %d\n", __FUNCTION__,
                         operatingch_info[4]);
                 pwdinfo->peer_operating_ch = operatingch_info[4];
             }
 
             p2p_ie =p2p_ie_to_get_func(p2p_ie + p2p_ielen,ies_len - (p2p_ie - ies + p2p_ielen), NULL,&p2p_ielen);
 
         }
     }
 
     return (result);
 }

 wf_u8 check_is_matched_in_profilelist_func(wf_u8 * peermacaddr,
                              struct profile_info * profileinfo, wf_u8 flag)
 {
     wf_u8 i, match_result = 0;
 
     P2P_FRAME_INFO("[%s] peermac = %.2X %.2X %.2X %.2X %.2X %.2X\n", __FUNCTION__,
             peermacaddr[0], peermacaddr[1], peermacaddr[2], peermacaddr[3],
             peermacaddr[4], peermacaddr[5]);
 
     for (i = 0; i < P2P_MAX_PERSISTENT_GROUP_NUM; i++, profileinfo++) 
     {
         P2P_FRAME_INFO("[%s] profileinfo_mac = %.2X %.2X %.2X %.2X %.2X %.2X\n",
                 __FUNCTION__, profileinfo->peermac[0], profileinfo->peermac[1],
                 profileinfo->peermac[2], profileinfo->peermac[3],
                 profileinfo->peermac[4], profileinfo->peermac[5]);
         if (0 == wf_memcmp(peermacaddr, profileinfo->peermac, WF_ETH_ALEN)) 
         {
             if (flag) 
             {
                 match_result = 1;
             }
             P2P_FRAME_INFO("[%s] Match!\n", __FUNCTION__);
             break;
         }
     }
 
     return (match_result);
 }

wf_s32 proc_ch_set_search_ch_func(wf_u8 flag, wf_channel_info_t * ch_set, const wf_u32 ch)
{
    wf_s32 i;
    for (i = 0; ch_set[i].channel_num != 0; i++) 
    {
        if (ch == ch_set[i].channel_num)
        {
            break;
        }
    }
    
    if (flag) 
    {
        if (i >= ch_set[i].channel_num)
        {
            return -1;
        }
    }
    
    return i;
}

 wf_s32 wf_p2p_action_public_proc(nic_info_st *pnic_info, wf_u8 *pframe, wf_u16 frame_len)
 {
     wf_u32 len = frame_len;
     wf_u8 *frame_body;
#ifdef WF_CONFIG_P2P
     wf_u8 *p2p_ie;
     wf_u32 p2p_ielen;
     //wf_u32 wps_ielen;
     p2p_info_st *p2p_info = pnic_info->p2p;
     p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;
     wf_u8 result = P2P_STATUS_SUCCESS;
     wf_u8 empty_addr[WF_ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
     wf_u8 *merged_p2pie = NULL;
     wf_u32 merged_p2p_ielen = 0;
#endif
 
     frame_body = (unsigned char *)(pframe + sizeof(struct wl_ieee80211_hdr_3addr));
 
#ifdef WF_CONFIG_P2P
     wf_os_api_timer_unreg(&p2p_info->reset_ch_sitesurvey);
#ifdef CONFIG_IOCTL_CFG80211
     if (p2p_info->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211) 
     {
        if(wf_true == p2p_info->scb.init_flag && p2p_info->scb.rx_mgmt)
        {
            P2P_FRAME_INFO("report p2p rx action frame");
            p2p_info->scb.rx_mgmt(pnic_info, pframe, len);
        }
     } else
#endif
     {
         if (pwdinfo->p2p_state == P2P_STATE_NONE || pwdinfo->p2p_state == P2P_STATE_IDLE)
         {
             return WF_RETURN_OK;
         }

         len -= sizeof(struct wl_ieee80211_hdr_3addr);
         
         switch (frame_body[6]) 
         {
         case P2P_GO_NEGO_REQ:
             {
                 P2P_FRAME_INFO("[%s] Got GO Nego Req Frame\n", __FUNCTION__);
                 wf_memset(&pwdinfo->groupid_info, 0x00,sizeof(struct group_id_info));
 
                 if (pwdinfo->p2p_state == P2P_STATE_RX_PROVISION_DIS_REQ) 
                 {
                     p2p_set_state(pwdinfo, pwdinfo->pre_p2p_state);
                 }
 
                 if (pwdinfo->p2p_state == P2P_STATE_GONEGO_FAIL) 
                 {
                     wf_os_api_timer_unreg(&p2p_info->restore_p2p_state_timer);
                     p2p_set_state(pwdinfo, pwdinfo->pre_p2p_state);
                     P2P_FRAME_INFO("[%s] Restore the previous p2p state to %d\n",__FUNCTION__, pwdinfo->p2p_state);
                 }
#ifdef CONFIG_CONCURRENT_MODE
                 if (wf_p2p_check_buddy_linkstate(pnic_info)) 
                 {
                     wf_os_api_timer_unreg(&p2p_info->ap_p2p_switch_timer);
                 }
#endif
 
                 if (pwdinfo->p2p_state !=P2P_STATE_GONEGO_ING)
                 {
                     p2p_set_pre_state(pwdinfo, pwdinfo->p2p_state);
                 }
 
                 if (0 == wf_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr,WF_ETH_ALEN))
                 {
                    wf_memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr,GetAddr2Ptr(pframe), WF_ETH_ALEN);
                 }
 
                 result = p2p_group_negotation_req_process_func(pnic_info, frame_body, len,1);
                 p2p_GO_response_to_issue_func(pnic_info, GetAddr2Ptr(pframe), frame_body,len, result, 1);
 
#ifdef CONFIG_CONCURRENT_MODE
                 wf_os_api_timer_set(&p2p_info->restore_p2p_state_timer, 3000);
#else
                 wf_os_api_timer_set(&p2p_info->restore_p2p_state_timer, 5000);
#endif
                 break;
             }
         case P2P_GO_NEGO_RESP:
             {
                 P2P_FRAME_INFO("[%s] Got GO Nego Resp Frame\n", __FUNCTION__);
 
                 if (pwdinfo->p2p_state == P2P_STATE_GONEGO_ING) 
                 {
                     wf_os_api_timer_unreg(&p2p_info->restore_p2p_state_timer);
                     pwdinfo->nego_req_info.benable = wf_false;
                     result =p2p_group_negotation_resp_process_func(pnic_info, frame_body,len, 1);
                     p2p_GO_confirm_to_issue_func(pnic_info, GetAddr2Ptr(pframe),result, 1);
                     if (P2P_STATUS_SUCCESS == result) {
                         if (pwdinfo->role == P2P_ROLE_CLIENT) {
                             pwdinfo->p2p_info.operation_ch[0] =
                                 pwdinfo->peer_operating_ch;
#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
                             pwdinfo->p2p_info.operation_ch[1] = 1;
                             pwdinfo->p2p_info.operation_ch[2] = 6;
                             pwdinfo->p2p_info.operation_ch[3] = 11;
#endif
                             pwdinfo->p2p_info.scan_op_ch_only = 1;
                             wf_os_api_timer_set(&p2p_info->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH);
                         }
                     }
 
                     pwdinfo->negotiation_dialog_token = 1;
 
                     if (pwdinfo->p2p_state == P2P_STATE_GONEGO_FAIL) {
                         wf_os_api_timer_set(&p2p_info->restore_p2p_state_timer, 5000);
                     }
                 } else {
                     P2P_FRAME_INFO
                         ("[%s] Skipped GO Nego Resp Frame (p2p_state != P2P_STATE_GONEGO_ING)\n",
                          __FUNCTION__);
                 }
 
                 break;
             }
         case P2P_GO_NEGO_CONF:
             {
                 P2P_FRAME_INFO("[%s] Got GO Nego Confirm Frame\n", __FUNCTION__);
                 result =
                     p2p_group_negotation_confirm_process_func(pnic_info, frame_body,
                                                          len, 1);
                 if (P2P_STATUS_SUCCESS == result) {
                     if (pwdinfo->role == P2P_ROLE_CLIENT) {
                         pwdinfo->p2p_info.operation_ch[0] =
                             pwdinfo->peer_operating_ch;
#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
                         pwdinfo->p2p_info.operation_ch[1] = 1;
                         pwdinfo->p2p_info.operation_ch[2] = 6;
                         pwdinfo->p2p_info.operation_ch[3] = 11;
#endif
                         pwdinfo->p2p_info.scan_op_ch_only = 1;
                         wf_os_api_timer_set(&p2p_info->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH);
                     }
                 }
                 break;
             }
         case P2P_INVIT_REQ:
             {
 
                 P2P_FRAME_INFO("[%s] Got invite request frame!\n", __FUNCTION__);
                 if ((p2p_ie =p2p_ie_to_get_func(frame_body + WF_PUBLIC_ACTION_IE_OFFSET,
                                     len - WF_PUBLIC_ACTION_IE_OFFSET, NULL,&p2p_ielen))) 
                 {
                     wf_u32 attr_contentlen = 0;
                     wf_u8 status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
                     struct group_id_info group_id;
                     wf_u8 invitation_flag = 0;
                     //wf_s32 j = 0;
 
                     merged_p2p_ielen = p2p_merged_ies_len_tp_get_func(frame_body +
                                                    WF_PUBLIC_ACTION_IE_OFFSET,
                                                    len -
                                                    WF_PUBLIC_ACTION_IE_OFFSET,
                                                    1);
 
                     merged_p2pie = wf_kzalloc(merged_p2p_ielen + 2);
                     if (merged_p2pie == NULL) 
                     {
                         P2P_FRAME_INFO("[%s] Malloc p2p ie fail\n", __FUNCTION__);
                         goto exit;
                     }
                     wf_memset(merged_p2pie, 0x00, merged_p2p_ielen);
 
                     merged_p2p_ielen =proc_p2p_merge_ies_func(frame_body +
                                           WF_PUBLIC_ACTION_IE_OFFSET,
                                           len - WF_PUBLIC_ACTION_IE_OFFSET,
                                           merged_p2pie, 1);
 
                     p2p_attr_content_to_get_func(merged_p2pie, merged_p2p_ielen,
                                              P2P_ATTR_INVITATION_FLAGS,
                                              &invitation_flag,
                                              &attr_contentlen);
                     if (attr_contentlen) 
                     {
                         p2p_attr_content_to_get_func(merged_p2pie, merged_p2p_ielen,
                                                  P2P_ATTR_GROUP_BSSID,
                                                  pwdinfo->p2p_peer_interface_addr,
                                                  &attr_contentlen);
 
                         if (attr_contentlen) 
                         {
                             P2P_FRAME_INFO("[%s] GO's BSSID = %.2X %.2X %.2X %.2X %.2X %.2X\n",
                                  __FUNCTION__,
                                  pwdinfo->p2p_peer_interface_addr[0],
                                  pwdinfo->p2p_peer_interface_addr[1],
                                  pwdinfo->p2p_peer_interface_addr[2],
                                  pwdinfo->p2p_peer_interface_addr[3],
                                  pwdinfo->p2p_peer_interface_addr[4],
                                  pwdinfo->p2p_peer_interface_addr[5]);
                         }
 
                         if (invitation_flag & P2P_INVITATION_FLAGS_PERSISTENT) {
 
                             wf_memset(&group_id, 0x00,sizeof(struct group_id_info));
                             p2p_attr_content_to_get_func(merged_p2pie,
                                                      merged_p2p_ielen,
                                                      P2P_ATTR_GROUP_ID,
                                                      (wf_u8 *) & group_id,
                                                      &attr_contentlen);
                             if (attr_contentlen) {
                                 if (0 == wf_memcmp(group_id.go_device_addr,nic_to_local_addr(pnic_info), WF_ETH_ALEN)) 
                                 {
                                     p2p_set_state(pwdinfo,P2P_STATE_RECV_INVITE_REQ_GO);
                                     p2p_set_role(pwdinfo, P2P_ROLE_GO);
                                     status_code = P2P_STATUS_SUCCESS;
                                 } 
                                 else 
                                 {
                                     if (check_is_matched_in_profilelist_func(pwdinfo->p2p_peer_interface_addr,&pwdinfo->profileinfo[0], 1))
                                        {
                                         wf_u8 operatingch_info[5] = { 0x00 };
                                         if (p2p_attr_content_to_get_func(merged_p2pie, merged_p2p_ielen,P2P_ATTR_OPERATING_CH,operatingch_info,&attr_contentlen)) 
                                         {
                                            hw_info_st *hw_info = pnic_info->hw_info;
                                             if (proc_ch_set_search_ch_func(1,hw_info->channel_set,(wf_u32) operatingch_info[4]) >=
                                                 0)
                                             {
                                                 pwdinfo->rx_invitereq_info.operation_ch[0] = operatingch_info[4];
#ifdef CONFIG_P2P_OP_CHK_SOCIAL_CH
                                                 pwdinfo->rx_invitereq_info.operation_ch[1] = 1;
                                                 pwdinfo->rx_invitereq_info.operation_ch[2] = 6;
                                                 pwdinfo->rx_invitereq_info.operation_ch[3] = 11;
#endif
                                                 pwdinfo->rx_invitereq_info.scan_op_ch_only = 1;
                                                 wf_os_api_timer_set(&p2p_info->reset_ch_sitesurvey,P2P_RESET_SCAN_CH);
                                                 p2p_set_state(pwdinfo,P2P_STATE_RECV_INVITE_REQ_MATCH);
                                                 p2p_set_role(pwdinfo,P2P_ROLE_CLIENT);
                                                 status_code =P2P_STATUS_SUCCESS;
                                             } 
                                             else 
                                             {
                                                 p2p_set_state(pwdinfo,P2P_STATE_RECV_INVITE_REQ_DISMATCH);
                                                 p2p_set_role(pwdinfo,P2P_ROLE_DEVICE);
                                                 status_code =P2P_STATUS_FAIL_NO_COMMON_CH;
                                                 wf_os_api_timer_set(&p2p_info->restore_p2p_state_timer,3000);
                                             }
                                         } 
                                         else 
                                         {
                                             p2p_set_state(pwdinfo,P2P_STATE_RECV_INVITE_REQ_MATCH);
                                             p2p_set_role(pwdinfo,P2P_ROLE_CLIENT);
                                             status_code = P2P_STATUS_SUCCESS;
                                         }
                                     } 
                                     else 
                                     {
                                         p2p_set_state(pwdinfo,P2P_STATE_RECV_INVITE_REQ_DISMATCH);
 
                                         status_code = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
                                     }
                                 }
                             } 
                             else 
                             {
                                 P2P_FRAME_INFO("[%s] P2P Group ID Attribute NOT FOUND!\n", __FUNCTION__);
                                 status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
                             }
                         } 
                         else 
                         {
                             wf_memset(&group_id, 0x00, sizeof(struct group_id_info));
                             p2p_attr_content_to_get_func(merged_p2pie,
                                                      merged_p2p_ielen,
                                                      P2P_ATTR_GROUP_ID,
                                                      (wf_u8 *) & group_id,
                                                      &attr_contentlen);
                             if (attr_contentlen) 
                             {
                                 if (0 == wf_memcmp(group_id.go_device_addr,nic_to_local_addr(pnic_info), WF_ETH_ALEN)) 
                                 {
                                     p2p_set_state(pwdinfo,
                                                       P2P_STATE_RECV_INVITE_REQ_DISMATCH);
                                     status_code =
                                         P2P_STATUS_FAIL_INFO_UNAVAILABLE;
                                 } else {
                                     wf_memcpy(pwdinfo->p2p_peer_device_addr,
                                                 group_id.go_device_addr,
                                                 WF_ETH_ALEN);
                                     p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
                                     p2p_set_state(pwdinfo,
                                                       P2P_STATE_RECV_INVITE_REQ_JOIN);
                                     status_code = P2P_STATUS_SUCCESS;
                                 }
                             } else {
                                 P2P_FRAME_INFO
                                     ("[%s] P2P Group ID Attribute NOT FOUND!\n",
                                      __FUNCTION__);
                                 status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
                             }
                         }
                     } else {
                         P2P_FRAME_INFO
                             ("[%s] P2P Invitation Flags Attribute NOT FOUND!\n",
                              __FUNCTION__);
                         status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
                     }
 
                     P2P_FRAME_INFO("[%s] status_code = %d\n", __FUNCTION__,
                             status_code);
 
                     pwdinfo->inviteresp_info.token = frame_body[7];
                     p2p_invitation_response_to_issue_func(pnic_info, GetAddr2Ptr(pframe),pwdinfo->inviteresp_info.token, status_code, 1);
                     wf_os_api_timer_set(&p2p_info->restore_p2p_state_timer, 3000);
                 }
                 break;
             }
         case P2P_INVIT_RESP:
             {
                 wf_u8 attr_content = 0x00;
                 wf_u32 attr_contentlen = 0;
 
                 P2P_FRAME_INFO("[%s] Got invite response frame!\n", __FUNCTION__);
                 wf_os_api_timer_unreg(&p2p_info->restore_p2p_state_timer);
                 if ((p2p_ie = p2p_ie_to_get_func(frame_body + WF_PUBLIC_ACTION_IE_OFFSET,len - WF_PUBLIC_ACTION_IE_OFFSET, NULL, &p2p_ielen))) 
                 {
                     p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_STATUS,&attr_content, &attr_contentlen);
                     if (attr_contentlen == 1) 
                     {
                         P2P_FRAME_INFO("[%s] Status = %d\n", __FUNCTION__,
                                 attr_content);
                         pwdinfo->invitereq_info.benable = wf_false;
 
                         if (attr_content == P2P_STATUS_SUCCESS) {
                             if (0 == wf_memcmp(pwdinfo->invitereq_info.go_bssid, nic_to_local_addr(pnic_info), WF_ETH_ALEN))
                                 p2p_set_role(pwdinfo, P2P_ROLE_GO);
                             else
                                 p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 
                             p2p_set_state(pwdinfo,
                                               P2P_STATE_RX_INVITE_RESP_OK);
                         } else {
                             p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
                             p2p_set_state(pwdinfo,
                                               P2P_STATE_RX_INVITE_RESP_FAIL);
                         }
                     } else {
                         p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
                         p2p_set_state(pwdinfo,
                                           P2P_STATE_RX_INVITE_RESP_FAIL);
                     }
                 } 
                 else 
                 {
                     p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
                     p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL);
                 }
 
                 if (pwdinfo->p2p_state == P2P_STATE_RX_INVITE_RESP_FAIL) 
                 {
                     wf_os_api_timer_set(&p2p_info->restore_p2p_state_timer, 5000);
                 }
                 break;
             }
         case P2P_DEVDISC_REQ:
 
             p2p_devdisc_req_process_func(pnic_info, pframe, len, 1);
 
             break;
 
         case P2P_DEVDISC_RESP:
 
             p2p_devdisc_resp_process_func(pnic_info, pframe, len, 1);
 
             break;
 
         case P2P_PROVISION_DISC_REQ:
             P2P_FRAME_INFO("[%s] Got Provisioning Discovery Request Frame\n", __FUNCTION__);
             p2p_provdisc_req_process_func(pnic_info, pframe, len, 1);
             wf_memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr,GetAddr2Ptr(pframe), WF_ETH_ALEN);
 
             if (pwdinfo->p2p_state != P2P_STATE_RX_PROVISION_DIS_REQ)
             {
                 p2p_set_pre_state(pwdinfo, pwdinfo->p2p_state);
             }
 
             p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
             wf_os_api_timer_set(&p2p_info->restore_p2p_state_timer,
                        P2P_PROVISION_TIMEOUT);
             break;
 
         case P2P_PROVISION_DISC_RESP:
             P2P_FRAME_INFO("[%s] Got Provisioning Discovery Response Frame\n",__FUNCTION__);
             wf_os_api_timer_unreg(&p2p_info->restore_p2p_state_timer);
             p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP);
             p2p_provdisc_resp_process_func(pnic_info, pframe, 1);
             wf_os_api_timer_set(&p2p_info->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
             break;
 
         }
     }
 
 exit:
 
     if (merged_p2pie) 
     {
         wf_kfree(merged_p2pie);
         merged_p2pie = NULL;
     }
#endif
     return WF_RETURN_OK;
 }

wf_s32 wf_p2p_frame_check(void *p2p, wf_u16 len)
{
    wf_80211_p2p_param_ie_t *pie = NULL;
    wf_u32 oui_value=0;
    
    if (NULL == p2p  || 0 ==len )
    {
        P2P_FRAME_WARN("NUll point");
        return -1;
    }
    
    pie = p2p;

    if (!(pie->element_id == WF_80211_MGMT_EID_VENDOR_SPECIFIC &&
        len >= WF_OFFSETOF(wf_80211_p2p_param_ie_t, oui) + pie->len))
    {
        P2P_FRAME_INFO("data corrupt");
        return -2;
    }

    oui_value = (pie->oui[0] << 16) | (pie->oui[1] << 8) | (pie->oui[2] << 0);
    P2P_FRAME_INFO("oui_value:0x%x,oui_type:0x%x",oui_value,pie->oui_type);
    if (!(oui_value == WF_80211_OUI_WFA && pie->oui_type == WF_80211_OUI_TYPE_WFA_P2P))
    {
        P2P_FRAME_INFO("no p2p element");
        return -3;
    }

    return 0;
}

wf_u8 *wf_p2p_ie_to_str(WF_P2P_IE_E ie_type)
{
    switch (ie_type)
    {
        case WF_P2P_IE_BEACON       : return to_str(WF_P2P_IE_BEACON);
        case WF_P2P_IE_PROBE_REQ    : return to_str(WF_P2P_IE_PROBE_REQ);
        case WF_P2P_IE_PROBE_RSP    : return to_str(WF_P2P_IE_PROBE_RSP);
        case WF_P2P_IE_ASSOC_REQ    : return to_str(WF_P2P_IE_ASSOC_REQ);
        case WF_P2P_IE_ASSOC_RSP    : return to_str(WF_P2P_IE_ASSOC_RSP);
        default:return to_str(WF_P2P_IE_MAX);
    }
    return "unknown ietype";
}
wf_s32 wf_p2p_fram_parse_ie(nic_info_st *pnic_info, void *p2p, wf_u16 len, WF_P2P_IE_E ie_type)
{
    wf_80211_p2p_param_ie_t *pie    = NULL;
    wf_s32 ret                      = 0;
    p2p_info_st *p2p_info           = NULL;
    p2p_wd_info_st *pwdinfo         = NULL;
    
    if (NULL == p2p  || 0 ==len || NULL == pnic_info)
    {
        P2P_FRAME_WARN("NUll point");
        return -1;
    }
    if(WF_P2P_IE_MAX <= ie_type)
    {
        P2P_FRAME_WARN("unknown ie type:%d",ie_type);
        return -2;
    }

    ret = wf_p2p_frame_check(p2p,len);
    if(ret)
    {
        P2P_FRAME_INFO("no p2p ie");
        return ret;
    }

    P2P_FRAME_DBG("[%d] parsing ie:%s",pnic_info->ndev_id,wf_p2p_ie_to_str(ie_type));
    p2p_info = pnic_info->p2p;
    pwdinfo = &p2p_info->wdinfo; 
    pie  = p2p;
    
    if(NULL != p2p_info->p2p_ie[ie_type])
    {
        wf_kfree(p2p_info->p2p_ie[ie_type]);
        p2p_info->p2p_ie[ie_type] = NULL;
        p2p_info->p2p_ie_len[ie_type] = 0;
    }

    log_array(pie,2 + pie->len);
    
    p2p_info->p2p_ie_len[ie_type] = 2 + pie->len;
    p2p_info->p2p_ie[ie_type] = wf_kzalloc(p2p_info->p2p_ie_len[ie_type]);
    if(NULL != p2p_info->p2p_ie[ie_type])
    {
        wf_memcpy(p2p_info->p2p_ie[ie_type],pie,p2p_info->p2p_ie_len[ie_type]);
    }
    else
    {
        LOG_E("wf_kzalloc for [%s] failed",wf_p2p_ie_to_str(ie_type));
    }
    
     return ret;
 }

wf_s32 wf_p2p_frame_assoc_req_proc(nic_info_st *pnic_info, wf_u8 * p2p_ie,wf_u32 p2p_ielen, wdn_net_info_st *pwdn_info, wf_u8 flag)
{
    wf_u8 status_code = P2P_STATUS_SUCCESS;
    wf_u8 *pbuf, *pattr_content = NULL;
    wf_u32 attr_contentlen = 0;
    wf_u16 cap_attr = 0;
    p2p_info_st *p2p_info = pnic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;

    if (flag && pwdinfo->role != P2P_ROLE_GO) 
    {
        return P2P_STATUS_FAIL_REQUEST_UNABLE;
    }

    if(p2p_ie) 
    {
        if (p2p_attr_content_to_get_func
            (p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (wf_u8 *) & cap_attr,(wf_u32 *) & attr_contentlen)) 
        {
            P2P_FRAME_INFO("[%s] Got P2P Capability Attr!!\n", __FUNCTION__);
            cap_attr = wf_le16_to_cpu(cap_attr);
            pwdn_info->dev_cap = cap_attr & 0xff;
        }

        if (p2p_attr_content_to_get_func(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL,
             (wf_u32 *) & attr_contentlen)) 
        {
            P2P_FRAME_INFO("[%s] Got P2P DEVICE INFO Attr!!\n", __FUNCTION__);
            pattr_content = pbuf = wf_kzalloc(attr_contentlen);
            if (pattr_content) 
            {
                wf_u8 num_of_secdev_type;
                wf_u16 dev_name_len;

                p2p_attr_content_to_get_func(p2p_ie, p2p_ielen,
                                         P2P_ATTR_DEVICE_INFO, pattr_content,
                                         (wf_u32 *) & attr_contentlen);

                wf_memcpy(pwdn_info->dev_addr, pattr_content, WF_ETH_ALEN);

                pattr_content += WF_ETH_ALEN;

                wf_memcpy(&pwdn_info->config_methods, pattr_content, 2);
                pwdn_info->config_methods = wf_be16_to_cpu(pwdn_info->config_methods);

                pattr_content += 2;

                wf_memcpy(pwdn_info->primary_dev_type, pattr_content, 8);

                pattr_content += 8;

                num_of_secdev_type = *pattr_content;
                pattr_content += 1;

                if (num_of_secdev_type == 0) {
                    pwdn_info->num_of_secdev_type = 0;
                } else {
                    wf_u32 len;

                    pwdn_info->num_of_secdev_type = num_of_secdev_type;

                    len =
                        (sizeof(pwdn_info->secdev_types_list) <
                         (num_of_secdev_type *
                          8)) ? (sizeof(pwdn_info->secdev_types_list))
                        : (num_of_secdev_type * 8);

                    wf_memcpy(pwdn_info->secdev_types_list, pattr_content, len);

                    pattr_content += (num_of_secdev_type * 8);
                }

                pwdn_info->dev_name_len = 0;
                if (WPS_ATTR_DEVICE_NAME == wf_be16_to_cpu(*(wf_u16 *) pattr_content)) {
                    dev_name_len = wf_be16_to_cpu(*(wf_u16 *) (pattr_content + 2));

                    pwdn_info->dev_name_len =
                        (sizeof(pwdn_info->dev_name) <
                         dev_name_len) ? sizeof(pwdn_info->dev_name) : dev_name_len;

                    wf_memcpy(pwdn_info->dev_name, pattr_content + 4,
                                pwdn_info->dev_name_len);
                }

                wf_kfree(pbuf);

            }

        }
    }

    return status_code;

}

#endif

