#include "common.h"
#include "wf_debug.h"

#if 1
#define P2P_PROTO_DBG(fmt, ...)      LOG_D("P2P_PROTO[%s:%d]"fmt, __func__,__LINE__, ##__VA_ARGS__)
#define P2P_PROTO_ARRAY(data, len)   log_array(data, len)
#else
#define P2P_PROTO_DBG(fmt, ...)
#define P2P_PROTO_ARRAY(data, len)
#endif

#define P2P_PROTO_INFO(fmt, ...)     LOG_I("P2P_PROTO[%s:%d]"fmt, __func__,__LINE__, ##__VA_ARGS__)
#define P2P_PROTO_WARN(fmt, ...)     LOG_E("P2P_PROTO[%s:%d]"fmt, __func__,__LINE__, ##__VA_ARGS__)


typedef wf_s32 (*proto_handle)(nic_info_st *nic_info);
typedef struct p2p_proto_ops_st_
{
    P2P_PROTO_WK_ID id;
    proto_handle proto_func;
}p2p_proto_ops_st;


static wf_s32 handler_p2p_concurrent_func(nic_info_st *nic_info)
{
    
    p2p_info_st *p2p_info = nic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;
    if(wf_p2p_check_buddy_linkstate(nic_info))
    {
        pwdinfo->operating_channel = wf_wlan_get_cur_channel(nic_info->buddy_nic);
        if (pwdinfo->driver_interface == DRIVER_CFG80211) 
        {
            wf_u8 current_bwmode = wf_wlan_get_cur_bw(nic_info->buddy_nic);

             wf_hw_info_set_channnel_bw(nic_info,pwdinfo->operating_channel,current_bwmode,HAL_PRIME_CHNL_OFFSET_DONT_CARE);
            
            //if (do_chk_partner_fwstate(pwadptdata, WIFI_FW_STATION_STATE))
            //    nulldata_to_pre_issue_func(pbuddy_wadptdata, NULL, 0, 3, 500);
        }
        else
        {
            LOG_I("WEXT for p2p to be doing.");
        }
    }
    else
    {
        if(P2P_STATE_GONEGO_OK != pwdinfo->p2p_state)
        {
            wf_hw_info_set_channnel_bw(nic_info,pwdinfo->listen_channel,CHANNEL_WIDTH_20,HAL_PRIME_CHNL_OFFSET_DONT_CARE);
        }
    }
    
    return 0;
}


static wf_s32 handler_find_phase_func(nic_info_st * nic_info)
{
    #if 0
    p2p_wd_info_st *pwdinfo = &pwadptdata->wdinfo;
    struct mlme_priv *pmlmepriv = &pwadptdata->mlmepriv;
    NDIS_802_11_SSID ssid;
    _irqL irqL;
    u8 _status = 0;

    _func_enter_;

    if (flag) {
        memset((unsigned char *)&ssid, 0, sizeof(NDIS_802_11_SSID));
        Func_Of_Proc_Pre_Memcpy(ssid.Ssid, pwdinfo->p2p_wildcard_ssid,
                    P2P_WILDCARD_SSID_LEN);
        ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
    }
    wl_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);

    spin_lock_bh(&pmlmepriv->lock);
    _status = proc_sitesurvey_cmd_func(pwadptdata, &ssid, 1, NULL, 0);
    spin_unlock_bh(&pmlmepriv->lock);

    _func_exit_;
    #else
    //p2p_info_st *p2p_info = nic_info->p2p;
    //p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;
    
    //wf_scan_start(nic_info,SCAN_TYPE_ACTIVE,NULL,pwdinfo->p2p_wildcard_ssid,1,);
    #endif
    return 0;
}

static wf_s32 p2p_state_handler_restore_func(nic_info_st *nic_info)
{
    p2p_info_st *p2p_info = nic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;
    
    if(P2P_STATE_GONEGO_ING == pwdinfo->p2p_state || P2P_STATE_GONEGO_FAIL == pwdinfo->p2p_state)
    {
        wf_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
    }
    if(wf_p2p_check_buddy_linkstate(nic_info))
    {
        if(P2P_STATE_TX_PROVISION_DIS_REQ == pwdinfo->p2p_state  || P2P_STATE_RX_PROVISION_DIS_RSP == pwdinfo->p2p_state)
        {
            wf_u8 cur_channel = wf_wlan_get_cur_channel(nic_info->buddy_nic);
            wf_u8 cur_bwmode  = wf_wlan_get_cur_bw(nic_info->buddy_nic);
            wf_hw_info_set_channnel_bw(nic_info->buddy_nic,cur_channel,cur_bwmode,HAL_PRIME_CHNL_OFFSET_DONT_CARE);
            //nulldata_to_pre_issue_func(pbuddy_wadptdata, NULL, 0, 3, 500);
        }
    }
    
    wf_p2p_set_state(pwdinfo, pwdinfo->pre_p2p_state);

    if (P2P_ROLE_DEVICE == pwdinfo->role ) 
    {
        if(nic_info->buddy_nic)
        {
            handler_p2p_concurrent_func(nic_info);
        }
        else
        {
            wf_hw_info_set_channnel_bw(nic_info,pwdinfo->listen_channel,CHANNEL_WIDTH_20,HAL_PRIME_CHNL_OFFSET_DONT_CARE);
        }
    }
    
    return 0;
}


static wf_s32 handler_pre_tx_provdisc_func(nic_info_st *nic_info)
{
    
    p2p_info_st *p2p_info = nic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;
    
    if(wf_p2p_check_buddy_linkstate(nic_info))
    {
        handler_p2p_concurrent_func(nic_info);
    }
    
    wf_hw_info_set_channnel_bw(nic_info,pwdinfo->tx_prov_disc_info.peer_channel_num[0],CHANNEL_WIDTH_20,HAL_PRIME_CHNL_OFFSET_DONT_CARE);
    wf_mcu_set_mlme_scan(nic_info,wf_true);
    wf_os_api_timer_set(&p2p_info->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);

    return 0;
}

static wf_s32 handler_pre_tx_invitereq_func(nic_info_st *nic_info)
{
    
    p2p_info_st *p2p_info = nic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;

    if(wf_p2p_check_buddy_linkstate(nic_info))
    {
        handler_p2p_concurrent_func(nic_info);
    }

    wf_hw_info_set_channnel_bw(nic_info,pwdinfo->invitereq_info.peer_ch,CHANNEL_WIDTH_20,HAL_PRIME_CHNL_OFFSET_DONT_CARE);
    wf_mcu_set_mlme_scan(nic_info,wf_true);
    wf_os_api_timer_set(&p2p_info->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
    

    return 0;
}

static wf_s32 handler_pre_tx_negoreq_func(nic_info_st *nic_info)
{
    
    p2p_info_st *p2p_info = nic_info->p2p;
    p2p_wd_info_st *pwdinfo = &p2p_info->wdinfo;
    
    if(wf_p2p_check_buddy_linkstate(nic_info))
    {
        handler_p2p_concurrent_func(nic_info);
    }
    
    wf_hw_info_set_channnel_bw(nic_info,pwdinfo->nego_req_info.peer_channel_num[0],CHANNEL_WIDTH_20,HAL_PRIME_CHNL_OFFSET_DONT_CARE);
    wf_mcu_set_mlme_scan(nic_info,wf_true);
    //probereq_p2p_to_pre_issue_func(pwadptdata, NULL);
    //probereq_p2p_to_pre_issue_func(pwadptdata, pwdinfo->nego_req_info.peerDevAddr);
    wf_os_api_timer_set(&p2p_info->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
    
    return 0;
}

static wf_s32 handler_ro_ch_func(nic_info_st *pnic_info)
{
    wf_u8 ch, bw, offset;
    p2p_wd_info_st *pwdinfo = NULL;
    p2p_info_st *p2p_info = pnic_info->p2p;
    wf_wlan_mgmt_info_t *pwlan_mgmt_info = NULL;
    wf_wlan_network_t *pcur_network = NULL;
    pwdinfo = &p2p_info->wdinfo;

    P2P_PROTO_DBG("start");
    
    pwlan_mgmt_info = (wf_wlan_mgmt_info_t *)pnic_info->wlan_mgmt_info;
    if(NULL == pwlan_mgmt_info)
    {
        return -1;
    }
    
    pcur_network = &pwlan_mgmt_info->cur_network;
    
    if (p2p_info->p2p_enabled && pwdinfo->listen_channel) 
    {
        ch = pwdinfo->listen_channel;
        bw = CHANNEL_WIDTH_20;
        offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
        P2P_PROTO_INFO(" back to listen ch - ch:%u, bw:%u, offset:%u\n",
                 ch, bw, offset);
    } 
    else 
    {
        ch = pwdinfo->restore_channel;
        bw = CHANNEL_WIDTH_20;
        offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
        P2P_PROTO_INFO(" back to restore ch - ch:%u, bw:%u, offset:%u\n",
                     ch, bw, offset);
    }
    
    pcur_network->channel = ch;
    wf_hw_info_set_channnel_bw(pnic_info, ch, offset, bw);

    pwdinfo->is_ro_ch = wf_false;
    pwdinfo->last_ro_ch_time = wf_os_api_timestamp();

    if(NULL != p2p_info->scb.remain_on_channel)
    {
        p2p_info->scb.remain_on_channel(pnic_info,NULL,0);
    }

    return 0;
}

static p2p_proto_ops_st gl_p2p_proto_funs[]=
{
    {P2P_FIND_PHASE_WK,handler_find_phase_func},
    {P2P_RESTORE_STATE_WK,p2p_state_handler_restore_func},
    {P2P_PRE_TX_PROVDISC_PROCESS_WK,handler_pre_tx_provdisc_func},
    {P2P_PRE_TX_NEGOREQ_PROCESS_WK,handler_pre_tx_negoreq_func},
    {P2P_PRE_TX_INVITEREQ_PROCESS_WK,handler_pre_tx_invitereq_func},
    {P2P_AP_P2P_CH_SWITCH_PROCESS_WK,handler_p2p_concurrent_func},
    {P2P_RO_CH_WK,handler_ro_ch_func}
};

char *proto_id_to_str(P2P_PROTO_WK_ID proto_id)
{
    switch(proto_id)
    {
        case P2P_FIND_PHASE_WK:
            return to_str(P2P_FIND_PHASE_WK);
        case P2P_RESTORE_STATE_WK:
            return to_str(P2P_RESTORE_STATE_WK);
        case P2P_PRE_TX_PROVDISC_PROCESS_WK:
            return to_str(P2P_PRE_TX_PROVDISC_PROCESS_WK);
        case P2P_PRE_TX_NEGOREQ_PROCESS_WK:
            return to_str(P2P_PRE_TX_NEGOREQ_PROCESS_WK);
        case P2P_PRE_TX_INVITEREQ_PROCESS_WK:
            return to_str(P2P_PRE_TX_INVITEREQ_PROCESS_WK);
            
        case P2P_AP_P2P_CH_SWITCH_PROCESS_WK:
            return to_str(P2P_AP_P2P_CH_SWITCH_PROCESS_WK);
        case P2P_RO_CH_WK:
            return to_str(P2P_RO_CH_WK);
        default:
            return "unknown proto_id";
    }
}
void wf_p2p_protocol_dispatch_entry(nic_info_st *nic_info, int proto_id)
{
    wf_s32 ret = 0;
    if(P2P_FIND_PHASE_WK > proto_id || proto_id > P2P_RO_CH_WK)
    {
        LOG_W("%s() proto_id:%d",__func__,proto_id);
    }
    
    if(gl_p2p_proto_funs[proto_id].proto_func)
    {
        ret = gl_p2p_proto_funs[proto_id].proto_func(nic_info);
        if(WF_RETURN_OK != ret)
        {
            LOG_E("%s() %s failed",__func__,proto_id_to_str(proto_id));
        }
    }
    else
    {
        LOG_E("%s()  no proto func",__func__);

    }
}

wf_s32 p2p_proto_queue_insert(p2p_proto_mgt_st *proto_mgt, P2P_PROTO_WK_ID proto_id)
{
    p2p_proto_node_st *node = NULL;

    if(NULL == proto_mgt)
    {
        LOG_E("[%s,%d] input param is null.",__func__,__LINE__);
        return WF_RETURN_FAIL;
    }
    
    node = wf_kzalloc(sizeof(p2p_proto_node_st));
    if(NULL == node)
    {
        return WF_RETURN_FAIL;
    }
    node->id = proto_id;
    wf_enque_tail(&node->list_node, &proto_mgt->proto_queue);
    wf_os_api_sema_post(&proto_mgt->proto_sema);
    return WF_RETURN_OK;
}

static wf_s32 p2p_proto_queue_remove(p2p_proto_mgt_st *proto_mgt, P2P_PROTO_WK_ID *proto_id)
{
    wf_que_list_t *node         = NULL;
    p2p_proto_node_st *tmp_node = NULL;

    if(NULL == proto_mgt)
    {
        LOG_E("[%s,%d] input param is null.",__func__,__LINE__);
        return WF_RETURN_FAIL;
    }
    
    if (wf_os_api_sema_wait(&proto_mgt->proto_sema))
    {
        return -2;
    }
    node = wf_deque_head(&proto_mgt->proto_queue);
    if(NULL == node)
    {
        return -3;
    }

    tmp_node = WF_CONTAINER_OF(node, p2p_proto_node_st, list_node);
    *proto_id = tmp_node->id;
    wf_kfree(tmp_node);
	
    return 0;
};


static void p2p_proto_queue_handle(nic_info_st *nic_info)
{
    p2p_info_st  *p2p               = NULL;
    wf_s32 ret                      = 0;
    wf_u8 exit_flag                 = 0;
    p2p_proto_mgt_st *p2p_proto_mgt = NULL;
    P2P_PROTO_WK_ID proto_id    = P2P_FIND_PHASE_WK;
    //wf_os_api_thread_affinity(DEFAULT_CPU_ID);

    while(1)
    {
        p2p = nic_info->p2p;
        p2p_proto_mgt = &p2p->p2p_proto_mgt;
        
        ret = p2p_proto_queue_remove(p2p_proto_mgt,&proto_id);
        if(ret)
        {
            LOG_D("exit_flag:%d",exit_flag);
            if((nic_info->is_driver_stopped == wf_true) || (nic_info->is_surprise_removed == wf_true))
            {
                break;
            }
            //LOG_I("[%s,%d] exe",__func__,__LINE__);
            continue;
        }
        if((nic_info->is_driver_stopped == wf_true) || (nic_info->is_surprise_removed == wf_true))
        {
            continue;
        }

        
        wf_p2p_protocol_dispatch_entry(nic_info,proto_id);
    }

    while(wf_os_api_thread_wait_stop(p2p_proto_mgt->proto_tid) == wf_false)
    {
        wf_msleep(10);
    }

    wf_os_api_thread_exit(p2p_proto_mgt->proto_tid);
}

wf_s32 p2p_proto_mgt_init(void *p2p)
{
    p2p_info_st *p2p_info           = NULL;
    p2p_proto_mgt_st *p2p_proto_mgt = NULL;
    nic_info_st *nic_info           = NULL;
    
    if(NULL == p2p)
    {
        LOG_E("[%s,%d] input param is null",__func__,__LINE__);
        return WF_RETURN_FAIL;
    }
    p2p_info = p2p;
    nic_info                        = p2p_info->nic_info;
    p2p_proto_mgt                   = &p2p_info->p2p_proto_mgt;
    wf_que_init(&p2p_proto_mgt->proto_queue,WF_LOCK_TYPE_SPIN);
    wf_os_api_sema_init(&p2p_proto_mgt->proto_sema, 0);

    sprintf(p2p_proto_mgt->proto_name,
            nic_info->virNic ? "p2p_proto_mgt:vir%d_%d" : "p2p_proto_mgt:wlan%d_%d",
            nic_info->hif_node_id, nic_info->ndev_id);
    if (NULL ==(p2p_proto_mgt->proto_tid=wf_os_api_thread_create(p2p_proto_mgt->proto_tid, p2p_proto_mgt->proto_name, p2p_proto_queue_handle, nic_info)))
    {
        LOG_E("[%s] create thread failed",__func__);
        return -1;
    }
    else
    {
        wf_os_api_thread_wakeup(p2p_proto_mgt->proto_tid);
    }

    return 0;
}

wf_s32 p2p_proto_mgt_term(void *p2p)
{
    p2p_proto_mgt_st *p2p_proto_mgt = NULL;
    p2p_info_st *p2p_info           = NULL;
    if(p2p)
    {
        return 0;
    }

    p2p_info = p2p;
    p2p_proto_mgt = &p2p_info->p2p_proto_mgt;
    if (p2p_proto_mgt && p2p_proto_mgt->proto_tid)
    {
        wf_os_api_sema_post(&p2p_proto_mgt->proto_sema);
        wf_os_api_thread_destory(p2p_proto_mgt->proto_tid);
        p2p_proto_mgt->proto_tid = NULL;
    }

    return 0;
}

